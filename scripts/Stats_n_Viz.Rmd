---
title: "p50"
output:
  html_document: default
  pdf_document: default
date: "2023-07-13"
---

```{r}
library(reshape2)
library(ggplot2)
library(visreg)
library(nlme)
```

```{r}
# prop angles
rs1=read.csv('~/Downloads/rs1_propsMerged(1).csv',header=F)
rs2=read.csv('~/Downloads/rs2_propsMerged(1).csv',header=F)
emo=read.csv('~/Downloads/emotion_propsMerged(1).csv',header=F)
gambling=read.csv('~/Downloads/gambling_propsMerged(1).csv',header=F)
wm=read.csv('~/Downloads/wm_propsMerged(1).csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V2,rs1$V3,rs1$V4,rs1$V17))
rs1p=data.frame(cbind(rs1$V5,rs1$V6,rs1$V7,rs1$V8,rs1$V18))
rs1m1=data.frame(cbind(rs1$V9,rs1$V10,rs1$V11,rs1$V12,rs1$V19))
rs1m2=data.frame(cbind(rs1$V13,rs1$V14,rs1$V15,rs1$V16,rs1$V20))
colnames(rs1bv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs1p)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs1m1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs1m2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V2,rs2$V3,rs2$V4,rs2$V17))
rs2p=data.frame(cbind(rs2$V5,rs2$V6,rs2$V7,rs2$V8,rs2$V18))
rs2m1=data.frame(cbind(rs2$V9,rs2$V10,rs2$V11,rs2$V12,rs2$V19))
rs2m2=data.frame(cbind(rs2$V13,rs2$V14,rs2$V15,rs2$V16,rs2$V20))
colnames(rs2bv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs2p)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs2m1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs2m2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V2,emo$V3,emo$V4,emo$V17))
emop=data.frame(cbind(emo$V5,emo$V6,emo$V7,emo$V8,emo$V18))
emom1=data.frame(cbind(emo$V9,emo$V10,emo$V11,emo$V12,emo$V19))
emom2=data.frame(cbind(emo$V13,emo$V14,emo$V15,emo$V16,emo$V20))
colnames(emobv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(emop)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(emom1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(emom2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V2,gambling$V3,gambling$V4,gambling$V17))
gamblingp=data.frame(cbind(gambling$V5,gambling$V6,gambling$V7,gambling$V8,gambling$V18))
gamblingm1=data.frame(cbind(gambling$V9,gambling$V10,gambling$V11,gambling$V12,gambling$V19))
gamblingm2=data.frame(cbind(gambling$V13,gambling$V14,gambling$V15,gambling$V16,gambling$V20))
colnames(gamblingbv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(gamblingp)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(gamblingm1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(gamblingm2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V2,wm$V3,wm$V4,wm$V17))
wmp=data.frame(cbind(wm$V5,wm$V6,wm$V7,wm$V8,wm$V18))
wmm1=data.frame(cbind(wm$V9,wm$V10,wm$V11,wm$V12,wm$V19))
wmm2=data.frame(cbind(wm$V13,wm$V14,wm$V15,wm$V16,wm$V20))
colnames(wmbv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(wmp)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(wmm1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(wmm2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# combine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)
mergedDf$Subjects<-as.factor(mergedDf$Subjects)
mergedDf$Dosage<-as.factor(mergedDf$Dosage)
mergedDfProps=mergedDf


# saveout merged DF for facewise analyses on HPC
saveRDS(mergedDf,'~/P50_cleaned_df.rds')
```

```{r}
## Read the data
#scanAnx <- read.csv('~/Downloads/P50MDMA-ScanNotes_DATA_2024-06-13_1309.csv')
#
## Create a data frame with the relevant columns
#scanAnx <- data.frame(Subjects = scanAnx$study_id, 
#                      AnxBL = scanAnx$anxietyscan_bl, 
#                      AnxS1 = scanAnx$anxietyscan_s1, 
#                      AnxS2 = scanAnx$anxietyscan_s2, 
#                      AnxS3 = scanAnx$anxietyscan_s3)
#
## Initialize an empty data frame for the longer format
#scanAnx_long <- data.frame(Subjects = integer(0), 
#                           Session = character(0), 
#                           Anx = numeric(0))
#
## Fill the new data frame
#for (i in 1:nrow(scanAnx)) {
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 0, 
#                                   Anx = scanAnx$AnxBL[i]))
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 1, 
#                                   Anx = scanAnx$AnxS1[i]))
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 2, 
#                                   Anx = scanAnx$AnxS2[i]))
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 3, 
#                                   Anx = scanAnx$AnxS3[i]))
#}
#
#scanAnx_long$Subjects <- paste0("sub-MDMA", gsub(" \\(c\\)", "", scanAnx_long$Subjects))
#scanAnx_long$Session=as.integer(scanAnx_long$Session)
#
## merge in
#mergedDf=merge(mergedDf,scanAnx_long,by=c('Subjects','Session'))
#
```


```{r}
# remove data that needs to be removed (subs 6 and 10, <250 TRs)
mergedDf=mergedDf[mergedDf$Subjects!='sub-MDMA006',]
mergedDf=mergedDf[mergedDf$Subjects!='sub-MDMA010',]
mergedDf=mergedDf[mergedDf$RemTRs>250,]

# save out version for implementing in vertex-wise analyses
saveRDS(mergedDf,'~/forVertexwise_MDMA.rds')
```

```{r}
# change rs2 to rs for accurate task-modeling
mergedDf$Task[mergedDf$Task=='rs2']='rs'
mergedDf$Task=as.factor(mergedDf$Task)
mergedDf_clean=mergedDf[mergedDf$Dosage!='baseline',]

# get head-motion regressed values for plotting
model_to_reg <- lm(TDProp1 ~ MeanFD + RemTRs+Task, data = mergedDf_clean)
mergedDf_clean$Residuals<-resid(model_to_reg)+mean(mergedDf_clean$TDProp1)

# figure 2a
ggplot(mergedDf_clean, aes(x = Drug, y = Residuals)) +
  geom_jitter(width = 0.25, height = 0, alpha = 0.5,size=4) +  # Jittered points
  geom_boxplot(alpha = 0.2,outlier.shape = NA) +     # Boxplot
  labs(title = "MDMA vs. Placebo \n",
       x = "",
       y = "% Bottom-up") + scale_x_discrete(labels=c('Placebo','MDMA'))+
  theme_minimal(base_size=25)

# full model for stats
fit_lme <- lme(TDProp1 ~ Drug + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = mergedDf_clean)
summaryLME<-summary(fit_lme)
#####
#### with all non-drug scans: Figure 2b
#####
# get head-motion regressed values for plotting
model_to_reg <- lm(TDProp1 ~ MeanFD + RemTRs+Task, data = mergedDf)
mergedDf$Residuals<-resid(model_to_reg)+mean(mergedDf$TDProp1)

# figure 2a
ggplot(mergedDf, aes(x = Drug, y = Residuals)) +
  geom_jitter(width = 0.25, height = 0, alpha = 0.5,size=4) +  # Jittered points
  geom_boxplot(alpha = 0.2,outlier.shape = NA) +     # Boxplot
  labs(title = "MDMA vs. No-drug scans \n",
       x = "",
       y = "% Bottom-up") + scale_x_discrete(labels=c('No Drug','MDMA'))+
  theme_minimal(base_size=25)

# full model for stats
fit_lme <- lme(TDProp1 ~ Drug + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = mergedDf)
summaryLME<-summary(fit_lme)
```

```{r}
# extract standout sessions/participants
library(dplyr)

# Calculate the difference in TDProp1 between Drug and Placebo conditions
df_diff <- mergedDf %>%
  group_by(Subjects) %>%
  summarise(Diff_TDProp1 = mean(TDProp1[Drug == 1]) - mean(TDProp1[Drug == 0], na.rm = TRUE))

# Identify the participant with the greatest increase in TDProp1
max_diff_subject <- df_diff %>%
  filter(Diff_TDProp1 == max(Diff_TDProp1, na.rm = TRUE)) %>%
  pull(Subjects)

print(max_diff_subject)
```


```{r}
# added chunk to code which sessions are post-mdma in macro timeline of study

# initialize new column in mergedDf
mergedDf$PostMDMASession <- 2

# load in subjSeshDoseCorrep (read delim, sep=' ')
subjSeshDoseCorrep <- read.table("~/Downloads/subjSeshDoseCorresp.csv", sep = ' ')

# for each subject
for (i in 1:nrow(subjSeshDoseCorrep)) {
  # if i <10
  if(i<10){
    subjectID <- paste0("sub-MDMA00", i)  # Reconstruct subject ID
  } else if(i>9){
    subjectID <- paste0("sub-MDMA0", i)  # Reconstruct subject ID
  }
  # get position of placebo
  placeboPos <- which(subjSeshDoseCorrep[i, 2:5] == "ses-01")
  print(placeboPos)
  # get position in mergedDf
  placeboRows <- mergedDf$Subject == subjectID & mergedDf$Dosage == "Placebo"
  # baseline is pos one, placebo is pos 2, 80 is pos 3, 120 is pos 4
  # if placebo is ses-01, leave as initialize 0
  # if placebo is ses-02, 1 for post-drugMacro
  # if placebo is ses-03, 1 for post-drugMacro
  if (placeboPos == 2) {
      mergedDf$PostMDMASession[placeboRows] <- 0
    } else if (placeboPos == 3 ) {
      mergedDf$PostMDMASession[placeboRows] <- 1
    } else if (placeboPos == 4) {
      mergedDf$PostMDMASession[placeboRows] <- 1
    }
}

# make post drug a separate placebo condition
mergedDf$Drug2<-as.numeric(mergedDf$Drug)
mergedDf$Drug2[mergedDf$PostMDMASession==1]=3
# placebo pre-drug is 1
# placebo post-drug is 3
# drug is 2

mergedDf$Drug2<-as.factor(mergedDf$Drug2)
mergedDf <- within(mergedDf, Drug2 <- relevel(Drug2, ref = 1))
# set MDMA visits to post MDMA
mergedDf$PostMDMASession[mergedDf$Drug==1]=1

model <- lme(TDProp1 ~ MeanFD +Drug2+ RemTRs, random = ~ 1 | Subjects, data = mergedDf)
```


```{r}
#meltedDf <- melt(mergedDf, id.vars = c("Subjects", "Task", "Dosage", "Session", "SpikesPercent", "MeanFD", "RemTRs", "Drug"))
#meltedDf <- within(meltedDf, variable <- relevel(variable, ref = 3))
#model <- lme(value ~ MeanFD + Drug + RemTRs+variable+variable*Drug+MeanFD*variable+RemTRs*variable, random = ~ 1 | Subjects/variable, data = meltedDf)
#summary(model)
#sjPlot::plot_model(model, type = "eff",show.values = T)
#
## great, now let's bootstrap it
## Set the number of bootstrap samples
#num_bootstrap_samples <- 1000
## initialize t vectors
#td1_d<-zeros(num_bootstrap_samples,1)
#td1_fd<-zeros(num_bootstrap_samples,1)
#td2_d<-zeros(num_bootstrap_samples,1)
#td2_fd<-zeros(num_bootstrap_samples,1)
#td3_d<-zeros(num_bootstrap_samples,1)
#td3_fd<-zeros(num_bootstrap_samples,1)
#td4_d<-zeros(num_bootstrap_samples,1)
#td4_fd<-zeros(num_bootstrap_samples,1)
#
## bootstrap loops
#set.seed(420)
#for (i in 1:num_bootstrap_samples){
#  # resample subjects instead of observations to be conserative
#	BootSubjs=sample(unique(mergedDf$Subjects),14,replace=T)
#	# Create an empty dataframe to store the resampled observations
#	bootSamp <- data.frame()
#	for (j in 1:length(BootSubjs)){
#		subject_obs <- meltedDf[meltedDf$Subjects == BootSubjs[j], ]
#		bootSamp <- rbind(bootSamp, subject_obs)
#	}
#  # fit model
#  model_i <- lme(value ~ MeanFD + Drug + RemTRs+variable+variable*Drug+variable*MeanFD, random = ~ 1 | Subjects/variable, data = bootSamp)
#  # get t-values
#  td1_d[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "Drug1:variableTDProp1", "t-value"]
#  td1_fd[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "MeanFD:variableTDProp1", "t-value"]
#  td3_d[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "Drug1:variableTDProp3", "t-value"]
#  td3_fd[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "MeanFD:variableTDProp3", "t-value"]
#  td4_d[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "Drug1:variableTDProp4", "t-value"]
#  td4_fd[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "MeanFD:variableTDProp4", "t-value"]
#}
#
#bootstrap_results=data.frame(cbind(td1_d,td1_fd,td3_d,td3_fd,td4_d,td4_fd))
#colnames(bootstrap_results)=c('td1_drug','td1_fd','td3_drug','td3_fd','td4_drug','td4_fd')
#plotdf=melt(bootstrap_results)
#
## Create box-and-whisker plots
#ggplot(plotdf, aes(x = variable, y = value,)) +
#  geom_boxplot(position = position_dodge(width = 0.8)) +
#  labs(x = "Model", y = "T-Values", title = "Bootstrap T-Values for Drug and MeanFD") +
#  theme_minimal(base_size = 16)+scale_fill_manual(values=c('blue','red'))
```

```{r}
# complexity
rs1=read.csv('~/Downloads/rs1_complexityMerged (3).csv',header=F)
rs2=read.csv('~/Downloads/rs2_complexityMerged (3).csv',header=F)
emo=read.csv('~/Downloads/emotion_complexityMerged (3).csv',header=F)
gambling=read.csv('~/Downloads/gambling_complexityMerged (3).csv',header=F)
wm=read.csv('~/Downloads/wm_complexityMerged (3).csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V5))
rs1p=data.frame(cbind(rs1$V2,rs1$V6))
rs1m1=data.frame(cbind(rs1$V3,rs1$V7))
rs1m2=data.frame(cbind(rs1$V4,rs1$V8))
colnames(rs1bv)=c('Complexity','RemTRs')
colnames(rs1p)=c('Complexity','RemTRs')
colnames(rs1m1)=c('Complexity','RemTRs')
colnames(rs1m2)=c('Complexity','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V5))
rs2p=data.frame(cbind(rs2$V2,rs2$V6))
rs2m1=data.frame(cbind(rs2$V3,rs2$V7))
rs2m2=data.frame(cbind(rs2$V4,rs2$V8))
colnames(rs2bv)=c('Complexity','RemTRs')
colnames(rs2p)=c('Complexity','RemTRs')
colnames(rs2m1)=c('Complexity','RemTRs')
colnames(rs2m2)=c('Complexity','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V5))
emop=data.frame(cbind(emo$V2,emo$V6))
emom1=data.frame(cbind(emo$V3,emo$V7))
emom2=data.frame(cbind(emo$V4,emo$V8))
colnames(emobv)=c('Complexity','RemTRs')
colnames(emop)=c('Complexity','RemTRs')
colnames(emom1)=c('Complexity','RemTRs')
colnames(emom2)=c('Complexity','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V5))
gamblingp=data.frame(cbind(gambling$V2,gambling$V6))
gamblingm1=data.frame(cbind(gambling$V3,gambling$V7))
gamblingm2=data.frame(cbind(gambling$V4,gambling$V8))
colnames(gamblingbv)=c('Complexity','RemTRs')
colnames(gamblingp)=c('Complexity','RemTRs')
colnames(gamblingm1)=c('Complexity','RemTRs')
colnames(gamblingm2)=c('Complexity','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V5))
wmp=data.frame(cbind(wm$V2,wm$V6))
wmm1=data.frame(cbind(wm$V3,wm$V7))
wmm2=data.frame(cbind(wm$V4,wm$V8))
colnames(wmbv)=c('Complexity','RemTRs')
colnames(wmp)=c('Complexity','RemTRs')
colnames(wmm1)=c('Complexity','RemTRs')
colnames(wmm2)=c('Complexity','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# comibine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf=mergedDf[mergedDf$Dosage!='baseline',]
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)

mergedDfPropsCompl=merge(mergedDfProps,mergedDf,by=c("Subjects","Task","Dosage","Session","MeanFD","SpikesPercent","RemTRs","Drug"))

```

```{r}
# autocorrelation
rs1=read.csv('~/Downloads/P50 MDMA/rs1_autocorMerged.csv',header=F)
rs2=read.csv('~/Downloads/P50 MDMA/rs2_autocorMerged.csv',header=F)
emo=read.csv('~/Downloads/P50 MDMA/emotion_autocorMerged.csv',header=F)
gambling=read.csv('~/Downloads/P50 MDMA/gambling_autocorMerged.csv',header=F)
wm=read.csv('~/Downloads/P50 MDMA/wm_autocorMerged.csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V5))
rs1p=data.frame(cbind(rs1$V2,rs1$V6))
rs1m1=data.frame(cbind(rs1$V3,rs1$V7))
rs1m2=data.frame(cbind(rs1$V4,rs1$V8))
colnames(rs1bv)=c('AutoCor','RemTRs')
colnames(rs1p)=c('AutoCor','RemTRs')
colnames(rs1m1)=c('AutoCor','RemTRs')
colnames(rs1m2)=c('AutoCor','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V5))
rs2p=data.frame(cbind(rs2$V2,rs2$V6))
rs2m1=data.frame(cbind(rs2$V3,rs2$V7))
rs2m2=data.frame(cbind(rs2$V4,rs2$V8))
colnames(rs2bv)=c('AutoCor','RemTRs')
colnames(rs2p)=c('AutoCor','RemTRs')
colnames(rs2m1)=c('AutoCor','RemTRs')
colnames(rs2m2)=c('AutoCor','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V5))
emop=data.frame(cbind(emo$V2,emo$V6))
emom1=data.frame(cbind(emo$V3,emo$V7))
emom2=data.frame(cbind(emo$V4,emo$V8))
colnames(emobv)=c('AutoCor','RemTRs')
colnames(emop)=c('AutoCor','RemTRs')
colnames(emom1)=c('AutoCor','RemTRs')
colnames(emom2)=c('AutoCor','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V5))
gamblingp=data.frame(cbind(gambling$V2,gambling$V6))
gamblingm1=data.frame(cbind(gambling$V3,gambling$V7))
gamblingm2=data.frame(cbind(gambling$V4,gambling$V8))
colnames(gamblingbv)=c('AutoCor','RemTRs')
colnames(gamblingp)=c('AutoCor','RemTRs')
colnames(gamblingm1)=c('AutoCor','RemTRs')
colnames(gamblingm2)=c('AutoCor','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V5))
wmp=data.frame(cbind(wm$V2,wm$V6))
wmm1=data.frame(cbind(wm$V3,wm$V7))
wmm2=data.frame(cbind(wm$V4,wm$V8))
colnames(wmbv)=c('AutoCor','RemTRs')
colnames(wmp)=c('AutoCor','RemTRs')
colnames(wmm1)=c('AutoCor','RemTRs')
colnames(wmm2)=c('AutoCor','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# comibine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf=mergedDf[mergedDf$Dosage!='baseline',]
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)
```

```{r}
# combine complexity and props
mergedDfPropsComplAutoC=merge(mergedDfPropsCompl,mergedDf,by=c("Subjects","Task","Dosage","Session","MeanFD","SpikesPercent","RemTRs","Drug"))
```

```{r}
# remove data that needs to be removed (subs 6 and 10, <250 TRs)
mergedDfPropsComplAutoC=mergedDfPropsComplAutoC[mergedDfPropsComplAutoC$Subjects!='sub-MDMA006',]
mergedDfPropsComplAutoC=mergedDfPropsComplAutoC[mergedDfPropsComplAutoC$Subjects!='sub-MDMA010',]
mergedDfPropsComplAutoC=mergedDfPropsComplAutoC[mergedDfPropsComplAutoC$RemTRs>250,]

# change rs2 to rs for accurate task-modeling
mergedDfPropsComplAutoC$Task[mergedDfPropsComplAutoC$Task=='rs2']='rs'
mergedDfPropsComplAutoC$Task=as.factor(mergedDfPropsComplAutoC$Task)

# set rs to reference level
mergedDfPropsComplAutoC <- within(mergedDfPropsComplAutoC, Task <- relevel(Task, ref = 2))

# model
td_model <- lme(TDProp1 ~ MeanFD + Drug+RemTRs, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoC)
sa_model <- lme(AutoCor ~ MeanFD + Drug+RemTRs, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoC)
cx_model <- lme(Complexity ~ MeanFD + Drug+RemTRs, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoC)
```

```{r}
# complexity plot

# preproc for plot
mergedDfPropsComplAutoC$Drug=0
mergedDfPropsComplAutoC$Drug[mergedDfPropsComplAutoC$Dosage=="120mg"]=1
mergedDfPropsComplAutoC$Drug[mergedDfPropsComplAutoC$Dosage=="80mg"]=1
mergedDfPropsComplAutoC$Drug=as.factor(mergedDfPropsComplAutoC$Drug)
mergedDfPropsComplAutoC$Subjects<-as.factor(mergedDfPropsComplAutoC$Subjects)
mergedDfPropsComplAutoC$Dosage<-as.factor(mergedDfPropsComplAutoC$Dosage)
# change rs2 to rs for accurate task-modeling
mergedDfPropsComplAutoC$Task[mergedDfPropsComplAutoC$Task=='rs2']='rs'
mergedDfPropsComplAutoC$Task=as.factor(mergedDfPropsComplAutoC$Task)
df_plot1=mergedDfPropsComplAutoC[mergedDfPropsComplAutoC$Dosage!="120mg",]
# for p-120
df_plot2=mergedDfPropsComplAutoC[mergedDfPropsComplAutoC$Dosage!="80mg",]
df_plot1$SubjectTask <- interaction(df_plot1$Subjects, df_plot1$Task)
df_plot2$SubjectTask <- interaction(df_plot2$Subjects, df_plot2$Task)

# Plotting
ggplot(df_plot1, aes(x = Drug, y = Complexity, fill = Drug, group = SubjectTask, color = Subjects)) +
  geom_point(size = 4, aes(alpha = 0.7)) +
  geom_line() +
  geom_point(data = df_plot2, aes(color = Subjects,alpha=.7), size = 4) +
  geom_line(data = df_plot2, aes(group = SubjectTask, color = Subjects)) +
  scale_color_viridis_d(option = "plasma") +
  ggtitle('All Scans') +
  theme_minimal(base_size = 22)

# by task
ggplot(mergedDfPropsComplAutoC, aes(x = Task, y = Complexity)) +
  geom_boxplot(size = 1, aes(alpha = 0.7)) +
  ggtitle('All Scans') +
  theme_minimal(base_size = 22)

cx_task_model <- lme(Complexity ~ MeanFD + Task+RemTRs, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoC)
```

```{r}
# briefly demonstrate lack of relationship between complexity and BUP
ggplot(mergedDfPropsComplAutoC,aes(x=Complexity,y=TDProp1))+geom_point()+theme_minimal(base_size=25)+ylab('Bottom-up %')
```

```{r}
# extract standout sessions/participants for COMPLEXITY this time
# Calculate the difference in Complexity between Drug and Placebo conditions
df_diff <- mergedDfPropsComplAutoC %>%
  group_by(Subjects) %>%
  summarise(Diff_Compl = mean(Complexity[Drug == 1]) - mean(Complexity[Drug == 0], na.rm = TRUE))

# Identify the participant with the greatest increase in Complexity
max_diff_subject <- df_diff %>%
  filter(Diff_Compl == max(Diff_Compl, na.rm = TRUE)) %>%
  pull(Subjects)


print(max_diff_subject)

```

```{r}
# great, now let's bootstrap them
# Set the number of bootstrap samples
num_bootstrap_samples <- 1000
# initialize t vectors
td_d<-rep(0,num_bootstrap_samples)
td_fd<-rep(0,num_bootstrap_samples)
sa_d<-rep(0,num_bootstrap_samples)
sa_fd<-rep(0,num_bootstrap_samples)
cx_d<-rep(0,num_bootstrap_samples)
cx_fd<-rep(0,num_bootstrap_samples)

# bootstrap loops
set.seed(1)
for (i in 1:num_bootstrap_samples){
  # resample data
  data=mergedDfPropsComplAutoC[sample(nrow(mergedDfPropsComplAutoC), replace = TRUE), ]
  # fit on all models
  td_model <- lme(TDProp1 ~ MeanFD + Drug+RemTRs, random = ~ 1 | Subjects, data = data)
  sa_model <- lme(AutoCor ~ MeanFD + Drug+RemTRs, random = ~ 1 | Subjects, data = data)
  cx_model <- lme(Complexity ~ MeanFD + Drug+RemTRs, random = ~ 1 | Subjects, data = data)
  # get t-values
  td_d[i]=summary(td_model)$tTable[rownames(summary(td_model)$tTable) == "Drug1", "t-value"]
  td_fd[i]=summary(td_model)$tTable[rownames(summary(td_model)$tTable) == "MeanFD", "t-value"]
  sa_d[i]=summary(sa_model)$tTable[rownames(summary(sa_model)$tTable) == "Drug1", "t-value"]
  sa_fd[i]=summary(sa_model)$tTable[rownames(summary(sa_model)$tTable) == "MeanFD", "t-value"]
  cx_d[i]=summary(cx_model)$tTable[rownames(summary(cx_model)$tTable) == "Drug1", "t-value"]
  cx_fd[i]=summary(cx_model)$tTable[rownames(summary(cx_model)$tTable) == "MeanFD", "t-value"]
  
}
# convert to dataframes
td_d=data.frame(td_d)
sa_d=data.frame(sa_d)
cx_d=data.frame(cx_d)
td_fd=data.frame(td_fd)
sa_fd=data.frame(sa_fd)
cx_fd=data.frame(cx_fd)
colnames(td_d)='tstat'
colnames(sa_d)='tstat'
colnames(cx_d)='tstat'
colnames(td_fd)='tstat'
colnames(sa_fd)='tstat'
colnames(cx_fd)='tstat'

# set column names for merging
td_d$Cov='Drug'
sa_d$Cov='Drug'
cx_d$Cov='Drug'
td_fd$Cov='FD'
sa_fd$Cov='FD'
cx_fd$Cov='FD'
td_d$Model='Top-Down'
sa_d$Model='AutoCor'
cx_d$Model='Complexity'
td_fd$Model='Top-Down'
sa_fd$Model='AutoCor'
cx_fd$Model='Complexity'
bootstrap_results=rbind(td_fd,td_d,sa_d,sa_fd,cx_d,cx_fd)

# Create box-and-whisker plots
ggplot(bootstrap_results, aes(x = Model, y = abs(tstat), fill = Cov)) +
  geom_boxplot(position = position_dodge(width = 0.8)) +
  labs(x = "Model", y = "T-Values", title = "Bootstrap T-Values for Drug and MeanFD") +
  theme_minimal(base_size = 16)+scale_fill_manual(values=c('blue','red'))

```


```{r}
# now compare with VAS
vas=read.csv('~/Downloads/MDMA_VAS_ASC_forAdam_03062023.csv')
# correct subject naming
vas$Subjects <- paste0("sub-MDMA", sprintf("%03d", vas$Subjects))
VASmerge=merge(vas,mergedDfPropsComplAutoC,by=c("Subjects","Dosage"))

# extract DAS for pca
Das=vas[,40:56]
# retain parallel version with subject names and session to recover them later
Das_SubjSesh=cbind(vas$Subjects,vas$Dosage,Das)

# Remove rows with NA values
DasNoNa <- na.omit(Das)
#parallel
Das_SubjSesh=na.omit(Das_SubjSesh)

# record subjets and sessions where all = 0
ZeroIndex=rowMeans(Das_SubjSesh[,3:19])==0
zeroSubjsRemade=Das_SubjSesh[ZeroIndex,]

# Check for rows with all zeros in the cleaned data
zero_rows <- apply(DasNoNa, 1, function(x) all(x == 0))
print(any(zero_rows))  # Should print TRUE

# Remove zero rows if found
DasNoNa <- DasNoNa[!zero_rows, ]
Das_SubjSesh <-Das_SubjSesh[!zero_rows, ]

# Verify the dimensions and check for NA values
print(dim(DasNoNa))
print(any(is.na(DasNoNa)))
print(dim(Das_SubjSesh))

# Load the NMF library
library(NMF)

# Function to calculate reconstruction error
reconstruction_error <- function(nmf_result, data) {
  fitted <- fitted(nmf_result)
  return(sqrt(sum((data - fitted)^2)))
}

# Range of components to test
num_components_range <- 1:12

# Store reconstruction errors
errors <- numeric(length(num_components_range))

set.seed(1)

# Calculate reconstruction errors for each number of components
for (k in num_components_range) {
  nmf_result <- nmf(DasNoNa, k)
  errors[k] <- reconstruction_error(nmf_result, DasNoNa)
}

# Plot reconstruction errors
plot(num_components_range, errors, type = "b", pch = 19, xlab = "Number of Components", ylab = "Reconstruction Error",
     main = "Reconstruction Error vs Number of Components")

# Set the number of components
num_components <- 8

# Run NMF
nmf_result <- nmf(DasNoNa, num_components)

# Extract the basis matrix (W) and coefficient matrix (H)
basis_matrix <- basis(nmf_result)
coef_matrix <- coef(nmf_result)

# make a vector of DAS scale names
dascNames=c('Oceaninc Boundlessness','Dread of Ego Dissolution','Visionary Restructuralization','Auditory Alterations','Vigilance Reduction','Global Effects','Experience of Unity','Spirtual Experience','Blissful State','Insightfulness','Disembodiment','Impaired Control','Anxiety','Complex Imagery','Elementary Imagery','Synsthesia','Changed meaning of precepts')


# Function to create and print plot for a specific component
create_plot <- function(component_index) {
  loadings <- coef_matrix[component_index, ]
  sorted_indices <- order(loadings, decreasing = TRUE)
  sorted_loadings <- loadings[sorted_indices]
  sorted_names <- dascNames[sorted_indices]
  
  loadings_df <- data.frame(Question = factor(sorted_names, levels = sorted_names), Loading = sorted_loadings)
  
  p <- ggplot(loadings_df, aes(x = Question, y = Loading)) +
    geom_bar(stat = "identity", fill = "gray") +
    ggtitle(paste("Component", component_index)) +
    theme_minimal(base_size=14) +
    theme(axis.text.x = element_text(angle = 70, hjust = 1)) +
    ylim(0, 0.35)+xlab('')
  
  print(p)
}
create_plot(1)
create_plot(2)
create_plot(3)
create_plot(4)
create_plot(5)
create_plot(6)
create_plot(7)
create_plot(8)


# use subj sesh to re-establish subject/session component loadings
Das_SubjSesh$Comp1<-basis_matrix[,1]
Das_SubjSesh$Comp2<-basis_matrix[,2]
Das_SubjSesh$Comp3<-basis_matrix[,3]
Das_SubjSesh$Comp4<-basis_matrix[,4]
Das_SubjSesh$Comp5<-basis_matrix[,5]
Das_SubjSesh$Comp6<-basis_matrix[,6]
Das_SubjSesh$Comp7<-basis_matrix[,7]
Das_SubjSesh$Comp8<-basis_matrix[,8]
```

```{r}
# set column names to equivalent
colnames(Das_SubjSesh)[1:2]<-c('Subjects','Dosage')
colnames(zeroSubjsRemade)[1:2]<-c('Subjects','Dosage')
### you CAN re-insert the 0-DAS items row for an extra piece of brain data... safe to assume they would load as 0 onto all components
zeroSubjsRemade$Comp1<-0
zeroSubjsRemade$Comp2<-0
zeroSubjsRemade$Comp3<-0
zeroSubjsRemade$Comp4<-0
zeroSubjsRemade$Comp5<-0
zeroSubjsRemade$Comp6<-0
zeroSubjsRemade$Comp7<-0
zeroSubjsRemade$Comp8<-0

# add back in
Das_SubjSesh=rbind(Das_SubjSesh,zeroSubjsRemade)

# regenerate 
mergedDf=merge(Das_SubjSesh,mergedDfPropsComplAutoC,by=c("Subjects","Dosage"))

# loop over each component (1-8), return coefficient and p-value of association with both complexity and tdprop1, populate 4 resultant vectors with these values for subsequent plotting

# Initialize vectors to store coefficients and p-values for subsequent plotting
coef_complexity <- numeric(8)
pval_complexity <- numeric(8)
coef_tdprop1 <- numeric(8)
pval_tdprop1 <- numeric(8)

# Loop over each component (1-8)
for (i in 1:8) {
  # Construct the formula dynamically for the current component
  formulaTD <- as.formula(paste("Comp", i, " ~ MeanFD + RemTRs + TDProp1+ Complexity", sep = ""))
  formulaCompl <- as.formula(paste("Comp", i, " ~ MeanFD + RemTRs + Complexity", sep = ""))
  # Fit the linear mixed-effects model
  modelT <- lme(formulaTD, random = ~ 1 | Subjects, data = mergedDf)
  modelC <- lme(formulaCompl, random = ~ 1 | Subjects, data = mergedDf)
  # Extract coefficients and p-values for both Complexity (Intercept) and TDProp1
  coef_complexity[i] <- summary(modelC)$tTable["Complexity", "t-value"]
  pval_complexity[i] <- summary(modelC)$tTable["Complexity", "p-value"]
  coef_tdprop1[i] <- summary(modelT)$tTable["TDProp1", "t-value"]
  pval_tdprop1[i] <- summary(modelT)$tTable["TDProp1", "p-value"]
}

```

```{r}
# plot it
library(circular)
library(plotrix)

# Adjust p-values for multiple comparisons using FDR method
pval_complexity_mc <- p.adjust(pval_complexity, method = 'fdr')
pval_tdprop1_mc <- p.adjust(pval_tdprop1, method = 'fdr')

# Create a data frame with the coefficients and p-values
plot_df <- data.frame(
  Component = factor(1:8),
  Coef_Complexity = coef_complexity,
  Pval_Complexity = pval_complexity,
  Coef_TDProp1 = -coef_tdprop1,
  Pval_TDProp1 = pval_tdprop1,
  Pval_Complexity_MC = pval_complexity_mc,
  Pval_TDProp1_MC = pval_tdprop1_mc
)

# Function to generate circular barplot with three colors
circular_barplot <- function(df, coef_column, pval_column, pval_mc_column, title) {
  ggplot(df, aes(x = Component, y = !!sym(coef_column))) +
    geom_bar(aes(fill = factor(ifelse(!!sym(pval_mc_column) < 0.05, "FDR", 
                                      ifelse(!!sym(pval_column) < 0.05, "Uncr", "NS")))), 
             stat = "identity", width = 0.8) +
    scale_fill_manual(values = c("FDR" = "red", "Uncr" = "blue", "NS" = "grey")) +
    coord_polar(theta = "x", start = 0) +
    labs(title = title, fill = "P-value") +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 12),
      axis.title = element_blank()
    )
}

circular_barplot(plot_df, "Coef_Complexity", "Pval_Complexity", "Pval_Complexity_MC", "Coefficients of Complexity")

circular_barplot(plot_df, "Coef_TDProp1", "Pval_TDProp1", "Pval_TDProp1_MC", "Coefficients of DMN Prop. Directions")

```


```{r}
# make a vector of DAS scale names
dascNames=c('Oceaninc Boundlessness','Dread of Ego Dissolution','Visionary Restructuralization','Auditory Alterations','Vigilance Reduction','Global Effects','Experience of Unity','Spirtual Experience','Blissful State','Insightfulness','Disembodiment','Impaired Control','Anxiety','Complex Imagery','Elementary Imagery','Synsthesia','Changed meaning of precepts')



# TD PROP
# initialize correlation vector for dasc
corvec=NULL
pvec=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + TDProp1")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','TDProp1','Subjects')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = TRUE)])
df$ColumnNamesFull<-dascNames
df$ColumnNamesFull <- factor(df$ColumnNamesFull, levels = df$ColumnNamesFull[order(df$Values, decreasing = TRUE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot: note negative Values for easy interp.
ggplot(df, aes(x = -Values, y = ColumnNamesFull,color=Sig)) +
  geom_point(size=3) + xlim(-5,5)+
  scale_color_manual(values = colors) +
  labs(x = "t-Values", y = "DAS Questions",title="Association with Propagation Directions")+theme_minimal(base_size=18)

  
# DRUG
# initialize correlation vector for dasc
corvec=NULL
pvec=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + Drug")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','Drug','Subjects')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNames,color=Sig)) +
  geom_point(size=3) + xlim(-20,20)+
  scale_color_manual(values = colors) +
  labs(x = "Values", y = "DAS Questions",title="Association with Drug")+theme_minimal(base_size=18)



# TD, COV DRUG
# initialize correlation vector for dasc
corvec=NULL
corvecD=NULL
pvec=NULL
pvecD=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + TDProp1 + Drug")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','TDProp1','Subjects','Drug')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1", "t-value"]
  corvecD[i-39]<- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1", "p-value"]
  pvecD[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNames,color=Sig)) +
  geom_point(size=3) + xlim(-20,20)+
  scale_color_manual(values = colors) +
  labs(x = "Values", y = "DAS Questions",title="TD Props, Covarying for Drug")+theme_minimal(base_size=18)

# drug covarying for td
# Create a dataframe with the values and column names
df <- data.frame(Values = corvecD, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvecD,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvecD<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNames,color=Sig)) +
  geom_point(size=3) + xlim(-20,20)+
  scale_color_manual(values = colors) +
  labs(x = "Values", y = "DAS Questions",title="Drug, Covarying for TDProps")+theme_minimal(base_size=18)


# COMPLEXITY
# initialize correlation vector for dasc
corvec=NULL
pvec=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + Complexity")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','Complexity','Subjects')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Complexity", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Complexity", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
df$ColumnNamesFull<-dascNames
df$ColumnNamesFull <- factor(df$ColumnNamesFull, levels = df$ColumnNamesFull[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNamesFull,color=Sig)) +
  geom_point(size=3) + xlim(-5,5)+
  scale_color_manual(values = colors) +
  labs(x = "t-Values", y = "DAS Questions",title="Association with Complexity")+theme_minimal(base_size=18)
```

```{r}
# load in angle histograms for more precise view of which direction of hierarchical propagations in changing

# placebo angles
placAngles=read.csv('~/Downloads/plac_subsAngHist.csv')

# mdma
mdmaAngles=read.csv('~/Downloads/drug_subsAngHist.csv')

# get normative sum of each column
placAnglesTot=colSums(placAngles)
# divide by total to get percentage for each
placAnglesTot=placAnglesTot/sum(placAngles)

# get normative sum of each column
mdmaAnglesTot=colSums(mdmaAngles)
# divide by total to get percentage for each
mdmaAnglesTot=mdmaAnglesTot/sum(mdmaAngles)


plotdataf<-data.frame(seq(1,18),placAnglesTot-mdmaAnglesTot)
# correct to be degrees rather than histogram bin index
plotdataf$seq.1..18.<-plotdataf$seq.1..18.*10

p<-ggplot(plotdataf,aes(x=seq.1..18.,y=placAnglesTot...mdmaAnglesTot))
p+geom_bar(stat='identity',color='black',aes(fill= ..x..),binwidth = 10)+xlab("Distance (Degrees)")+theme_classic(base_size = 23)+scale_x_continuous(limits=(c(0,190)))+scale_fill_gradientn("value",colors=c("blue","cyan","green","yellow","orange","red"))+ggtitle("Placebo - MDMA Propagation Directions")+theme(plot.title= element_text(size=30, face="bold"), axis.title = element_text(size=30, face="bold"),axis.text = element_text(face="bold",size=30),legend.title=element_blank(),legend.text=element_text(size=20),legend.position=c(1.07,.41),plot.margin=margin(b=.1,t=.1,l=.1,r=2.3, unit='cm'))+ylab('Propagation %')
```

```{r}
# simple plot of point estimates of different drugs
tvector=c(4.26465,3.63167,2.621,-0.30648,-0.27721)
drugVector=c('LSD (mice)', 'MDMA','Psilocybin','Ritalin','Ketamine')
# make dataframe
plotdf=data.frame(tvector,drugVector)
# sort order
plotdf$drugVector <- factor(plotdf$drugVector, levels = plotdf$drugVector[order(plotdf$tvector, decreasing = TRUE)])
ggplot(data=plotdf,aes(x=drugVector,y=tvector))+geom_point(size=8)+theme_minimal(base_size=30)+xlab('Drug')+ylab('t-Values')
```


```{r}
library(igraph)
# create a correlation matrix of DAS items for a spring loaded graph
Das <- vas[, 40:56]

# Calculate the correlation matrix
cor_matrix <- cor(Das, use = "complete.obs")

# Convert the correlation matrix to an adjacency matrix
# You can set a threshold to filter out weak correlations
threshold <- 0.6
adj_matrix <- cor_matrix
adj_matrix[abs(adj_matrix) < threshold] <- 0

# Create a graph object
graph <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# Set vertex labels
V(graph)$name <- dascNames

# Perform community detection using the Louvain method
communities <- cluster_louvain(graph)

# Add community membership as a vertex attribute
V(graph)$community <- communities$membership

# Set a color palette for the communities
community_colors <- rainbow(length(unique(V(graph)$community)))

layout_fr <- layout_with_fr(graph, weights = E(graph)$weight)

# Plot the graph with a spring layout and community colors
plot(graph, layout = layout_fr, vertex.label = V(graph)$name,
     vertex.size = 15, vertex.label.cex = 0.8, edge.width = E(graph)$weight * 2,
     vertex.color = community_colors[V(graph)$community], main = "Spring-loaded Graph of DAS Items with Communities")

```

```{r}
# Calculate within-module and between-module correlations for each node
within_between_ratios <- numeric(vcount(graph))

for (node in 1:vcount(graph)) {
  community <- V(graph)$community[node]
  
  # Nodes in the same community
  community_nodes <- which(V(graph)$community == community)
  
  # Nodes in different communities
  other_nodes <- which(V(graph)$community != community)
  
  # Within-module correlations
  within_correlations <- cor_matrix[node, community_nodes]
  # drop autocorrelation
  within_correlations=within_correlations[within_correlations!=1.0]
  avg_within <- mean(within_correlations[within_correlations != 0])
  
  # Between-module correlations
  between_correlations <- cor_matrix[node, other_nodes]
  avg_between <- mean(between_correlations[between_correlations != 0])
  
  if (is.na(avg_within)) avg_within <- 0
  if (is.na(avg_between)) avg_between <- 0
  
  within_between_ratios[node] <- avg_within / avg_between
}

# Normalize ratios for coloring
colors <- colorRampPalette(c("blue", "red"))(length(unique(within_between_ratios)))

# Assign colors based on normalized ratios
V(graph)$color <- colors[as.numeric(cut(within_between_ratios, breaks = length(colors)))]

# Plot the graph with a spring layout and ratio colors
plot(graph, layout = layout_fr, vertex.label = V(graph)$name,
     vertex.size = 15, vertex.label.cex = 0.8, edge.width = E(graph)$weight * 2,
     vertex.color = V(graph)$color, main = "Spring-loaded Graph of DAS Items with Within/Between Ratio")

# Additional customization (optional)
plot(graph, layout = layout_with_fr, vertex.label = V(graph)$name,
     vertex.size = 15, vertex.label.cex = 0.8, edge.width = E(graph)$weight * 2,
     vertex.color = V(graph)$color, edge.color = "gray", 
     main = "Spring-loaded Graph of DAS Items with Within/Between Ratio")
```
