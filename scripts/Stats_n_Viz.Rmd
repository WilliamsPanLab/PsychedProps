---
title: "p50"
output:
  html_document: default
  pdf_document: default
date: "2023-07-13"
---

```{r}
library(reshape2)
library(ggplot2)
library(visreg)
library(nlme)
```

```{r}
# prop angles
rs1=read.csv('~/Downloads/rs1_propsMerged(4).csv',header=F)
rs2=read.csv('~/Downloads/rs2_propsMerged(4).csv',header=F)
emo=read.csv('~/Downloads/emotion_propsMerged(4).csv',header=F)
gambling=read.csv('~/Downloads/gambling_propsMerged(4).csv',header=F)
wm=read.csv('~/Downloads/wm_propsMerged(4).csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V2,rs1$V3,rs1$V4,rs1$V17))
rs1p=data.frame(cbind(rs1$V5,rs1$V6,rs1$V7,rs1$V8,rs1$V18))
rs1m1=data.frame(cbind(rs1$V9,rs1$V10,rs1$V11,rs1$V12,rs1$V19))
rs1m2=data.frame(cbind(rs1$V13,rs1$V14,rs1$V15,rs1$V16,rs1$V20))
colnames(rs1bv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs1p)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs1m1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs1m2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V2,rs2$V3,rs2$V4,rs2$V17))
rs2p=data.frame(cbind(rs2$V5,rs2$V6,rs2$V7,rs2$V8,rs2$V18))
rs2m1=data.frame(cbind(rs2$V9,rs2$V10,rs2$V11,rs2$V12,rs2$V19))
rs2m2=data.frame(cbind(rs2$V13,rs2$V14,rs2$V15,rs2$V16,rs2$V20))
colnames(rs2bv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs2p)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs2m1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(rs2m2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V2,emo$V3,emo$V4,emo$V17))
emop=data.frame(cbind(emo$V5,emo$V6,emo$V7,emo$V8,emo$V18))
emom1=data.frame(cbind(emo$V9,emo$V10,emo$V11,emo$V12,emo$V19))
emom2=data.frame(cbind(emo$V13,emo$V14,emo$V15,emo$V16,emo$V20))
colnames(emobv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(emop)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(emom1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(emom2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V2,gambling$V3,gambling$V4,gambling$V17))
gamblingp=data.frame(cbind(gambling$V5,gambling$V6,gambling$V7,gambling$V8,gambling$V18))
gamblingm1=data.frame(cbind(gambling$V9,gambling$V10,gambling$V11,gambling$V12,gambling$V19))
gamblingm2=data.frame(cbind(gambling$V13,gambling$V14,gambling$V15,gambling$V16,gambling$V20))
colnames(gamblingbv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(gamblingp)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(gamblingm1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(gamblingm2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V2,wm$V3,wm$V4,wm$V17))
wmp=data.frame(cbind(wm$V5,wm$V6,wm$V7,wm$V8,wm$V18))
wmm1=data.frame(cbind(wm$V9,wm$V10,wm$V11,wm$V12,wm$V19))
wmm2=data.frame(cbind(wm$V13,wm$V14,wm$V15,wm$V16,wm$V20))
colnames(wmbv)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(wmp)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(wmm1)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')
colnames(wmm2)=c('TDProp1','TDProp2','TDProp3','TDProp4','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# combine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)
mergedDf$Subjects<-as.factor(mergedDf$Subjects)
mergedDf$Dosage<-as.factor(mergedDf$Dosage)
mergedDfProps=mergedDf


# saveout merged DF for facewise analyses on HPC
saveRDS(mergedDf,'~/P50_cleaned_df.rds')
```

```{r}
## Read the data
#scanAnx <- read.csv('~/Downloads/P50MDMA-ScanNotes_DATA_2024-06-13_1309.csv')
#
## Create a data frame with the relevant columns
#scanAnx <- data.frame(Subjects = scanAnx$study_id, 
#                      AnxBL = scanAnx$anxietyscan_bl, 
#                      AnxS1 = scanAnx$anxietyscan_s1, 
#                      AnxS2 = scanAnx$anxietyscan_s2, 
#                      AnxS3 = scanAnx$anxietyscan_s3)
#
## Initialize an empty data frame for the longer format
#scanAnx_long <- data.frame(Subjects = integer(0), 
#                           Session = character(0), 
#                           Anx = numeric(0))
#
## Fill the new data frame
#for (i in 1:nrow(scanAnx)) {
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 0, 
#                                   Anx = scanAnx$AnxBL[i]))
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 1, 
#                                   Anx = scanAnx$AnxS1[i]))
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 2, 
#                                   Anx = scanAnx$AnxS2[i]))
#  scanAnx_long <- rbind(scanAnx_long, 
#                        data.frame(Subjects = scanAnx$Subjects[i], 
#                                   Session = 3, 
#                                   Anx = scanAnx$AnxS3[i]))
#}
#
#scanAnx_long$Subjects <- paste0("sub-MDMA", gsub(" \\(c\\)", "", scanAnx_long$Subjects))
#scanAnx_long$Session=as.integer(scanAnx_long$Session)
#
## merge in
#mergedDf=merge(mergedDf,scanAnx_long,by=c('Subjects','Session'))
#
```


```{r}
# remove data that needs to be removed (subs 6 and 10, <250 TRs)
mergedDf=mergedDf[mergedDf$Subjects!='sub-MDMA006',]
mergedDf=mergedDf[mergedDf$Subjects!='sub-MDMA010',]
mergedDf=mergedDf[mergedDf$RemTRs>250,]

# save out version for implementing in vertex-wise analyses
saveRDS(mergedDf,'~/forVertexwise_MDMA.rds')
```

```{r}
# assign clearer subject labels
# get unique subj names
mergedDf$Subjects <- droplevels(mergedDf$Subjects)
unique_values <- unique(mergedDf$Subjects)
new_labels <- paste0("sub-MDMA", seq_along(unique_values))
names(new_labels) <- unique_values

# Replace the values in Subjects using the new labels
mergedDf$People <- new_labels[mergedDf$Subjects]

# final ordering
mergedDf$People <- factor(mergedDf$People, levels = new_labels)

# change rs2 to rs for accurate task-modeling
mergedDf$Task[mergedDf$Task=='rs2']='rs'
mergedDf$Task=as.factor(mergedDf$Task)
mergedDf_clean=mergedDf[mergedDf$Dosage!='baseline',]

# make donut plot
donutData<- data.frame(
  Category=levels(mergedDf$Dosage),
  count=tabulate(mergedDf$Dosage)
)

# convert labels to be consistent across studies
donutData$Category=c('Psychedelic','x','Baseline','Placebo')
# merge 120 and 80mg for clear plots
donutData$count[donutData$Category=='Psychedelic']=donutData$count[donutData$Category=='Psychedelic']+donutData$count[donutData$Category=='x']
donutData=donutData[donutData$Category!='x',]

# percentages
donutData$frac = donutData$count / sum(donutData$count)

# Compute the cumulative for plotting
donutData$ymax = cumsum(donutData$frac)

# Compute the bottom of each rectangle (plotted as rectangle and coord_polar'ed)
donutData$ymin = c(0, head(donutData$ymax, n=-1))

# convert to factor for manual ordering
donutData$Category <- factor(donutData$Category, levels = c('Placebo', 'Baseline', 'Psychedelic'))


# plot
ggplot(donutData, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=Category)) +
     geom_rect() +
     coord_polar(theta="y") + 
     xlim(c(1, 4)) + theme_classic(base_size=28)+theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.line = element_blank()
  )+guides(fill = guide_legend(title = NULL))+scale_fill_manual(values = c("#EF9500","#002642","#840032"))


# generate extended color pal for subject plotting
library(grDevices)
# Define the extended custom palette function
extended_palette <- colorRampPalette(rev(c("#FFEE00", "#EF9500", "#002642", "#c1004f", "#000000")))

# Generate a palette with the number of unique levels in V1
num_colors <- length(unique(mergedDf_clean$Subjects))
generated_colors <- extended_palette(num_colors)

# get head-motion regressed values for plotting
model_to_reg <- lm(TDProp1 ~ MeanFD + RemTRs+Task, data = mergedDf_clean)
mergedDf_clean$Residuals<-resid(model_to_reg)+mean(mergedDf_clean$TDProp1)

# figure 2a
ggplot(mergedDf_clean, aes(x = Drug, y = Residuals)) +
  geom_jitter(width = 0.25, height = 0, alpha = 0.8,size=4,aes(color = People)) +  # Jittered points
  geom_boxplot(alpha = 0.2,outlier.shape = NA) +     # Boxplot
  labs(title = "MDMA vs. Placebo \n",
       x = "",
       y = "% Bottom-up") + scale_x_discrete(labels=c('Placebo','MDMA'))+
  scale_color_manual(values = generated_colors)+
  theme_minimal(base_size=28)


# job application version - 350 x 650
ggplot(mergedDf_clean, aes(x = Drug, y = Residuals)) +
  geom_jitter(width = 0.25, height = 0, alpha = 0.8, size = 2, aes(color = People)) +  # Jittered points
  geom_boxplot(alpha = 0.2, outlier.shape = NA) +     # Boxplot
  labs(x = "",
       y = "% Bottom-up") +
  scale_x_discrete(labels = c('Placebo', 'MDMA')) +
  scale_color_manual(values = generated_colors) +  # Custom generated color palette
  theme_minimal(base_size = 28)+
  theme(legend.position = "none",axis.text.x=element_text(angle=45))

# full model for stats
fit_lme <- lme(TDProp1 ~ Drug + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = mergedDf_clean)
summaryLME<-summary(fit_lme)

# testing lme4 for robustness
library(lme4)
library(lmerTest)
fit_lmer <- lmer(TDProp1 ~ Drug + RemTRs + MeanFD+Task + (1 | Subjects), data = mergedDf_clean)
# checks out

#####
#### with all non-drug scans: Figure 2b
#####

# get head-motion regressed values for plotting
model_to_reg <- lm(TDProp1 ~ MeanFD + RemTRs+Task, data = mergedDf)
mergedDf$Residuals<-resid(model_to_reg)+mean(mergedDf$TDProp1)

# figure 2a
ggplot(mergedDf, aes(x = Drug, y = Residuals)) +
  geom_jitter(width = 0.25, height = 0, alpha = 0.8,size=4,aes(color = People)) +  # Jittered points
  geom_boxplot(alpha = 0.2,outlier.shape = NA) +     # Boxplot
  labs(title = "MDMA vs. No-drug scans \n",
       x = "",
       y = "% Bottom-up") + scale_x_discrete(labels=c('No Drug','MDMA'))+
  theme_minimal(base_size=25)+scale_color_manual(values = generated_colors)

# full model for stats
fit_lme <- lme(TDProp1 ~ Drug + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = mergedDf)
summaryLME<-summary(fit_lme)

# lme4 test for robustness
fit_lmer <- lmer(TDProp1 ~ Drug + RemTRs + MeanFD+Task + (1 | Subjects), data = mergedDf)
# checks out

# make a "people"-"subjects" equivalence data frame to reference in figures down below
unique_pairs <- unique(mergedDf[c("People", "Subjects")])
```

```{r}
# extract standout sessions/participants
library(dplyr)

# Calculate the difference in TDProp1 between Drug and Placebo conditions
df_diff <- mergedDf %>%
  group_by(Subjects) %>%
  summarise(Diff_TDProp1 = mean(TDProp1[Drug == 1]) - mean(TDProp1[Drug == 0], na.rm = TRUE))

# Identify the participant with the greatest increase in TDProp1
max_diff_subject <- df_diff %>%
  filter(Diff_TDProp1 == max(Diff_TDProp1, na.rm = TRUE)) %>%
  pull(Subjects)

print(max_diff_subject)
```


```{r}
# added chunk to code which sessions are post-mdma in macro timeline of study

# initialize new column in mergedDf
mergedDf$PostMDMASession <- 2

# load in subjSeshDoseCorrep (read delim, sep=' ')
subjSeshDoseCorrep <- read.table("~/Downloads/subjSeshDoseCorresp.csv", sep = ' ')

# for each subject
for (i in 1:nrow(subjSeshDoseCorrep)) {
  # if i <10
  if(i<10){
    subjectID <- paste0("sub-MDMA00", i)  # Reconstruct subject ID
  } else if(i>9){
    subjectID <- paste0("sub-MDMA0", i)  # Reconstruct subject ID
  }
  # get position of placebo
  placeboPos <- which(subjSeshDoseCorrep[i, 2:5] == "ses-01")
  print(placeboPos)
  # get position in mergedDf
  placeboRows <- mergedDf$Subject == subjectID & mergedDf$Dosage == "Placebo"
  # baseline is pos one, placebo is pos 2, 80 is pos 3, 120 is pos 4
  # if placebo is ses-01, leave as initialize 0
  # if placebo is ses-02, 1 for post-drugMacro
  # if placebo is ses-03, 1 for post-drugMacro
  if (placeboPos == 2) {
      mergedDf$PostMDMASession[placeboRows] <- 0
    } else if (placeboPos == 3 ) {
      mergedDf$PostMDMASession[placeboRows] <- 1
    } else if (placeboPos == 4) {
      mergedDf$PostMDMASession[placeboRows] <- 1
    }
}

# make post drug a separate placebo condition
mergedDf$Drug2<-as.numeric(mergedDf$Drug)
mergedDf$Drug2[mergedDf$PostMDMASession==1]=3
# placebo pre-drug is 1
# placebo post-drug is 3
# drug is 2

mergedDf$Drug2<-as.factor(mergedDf$Drug2)
mergedDf <- within(mergedDf, Drug2 <- relevel(Drug2, ref = 1))
# set MDMA visits to post MDMA
mergedDf$PostMDMASession[mergedDf$Drug==1]=1

model <- lme(TDProp1 ~ MeanFD +Drug2+ RemTRs, random = ~ 1 | Subjects, data = mergedDf)
```


```{r}
#meltedDf <- melt(mergedDf, id.vars = c("Subjects", "Task", "Dosage", "Session", "SpikesPercent", "MeanFD", "RemTRs", "Drug"))
#meltedDf <- within(meltedDf, variable <- relevel(variable, ref = 3))
#model <- lme(value ~ MeanFD + Drug + RemTRs+variable+variable*Drug+MeanFD*variable+RemTRs*variable, random = ~ 1 | Subjects/variable, data = meltedDf)
#summary(model)
#sjPlot::plot_model(model, type = "eff",show.values = T)
#
## great, now let's bootstrap it
## Set the number of bootstrap samples
#num_bootstrap_samples <- 
## initialize t vectors
#td1_d<-zeros(num_bootstrap_samples,1)
#td1_fd<-zeros(num_bootstrap_samples,1)
#td2_d<-zeros(num_bootstrap_samples,1)
#td2_fd<-zeros(num_bootstrap_samples,1)
#td3_d<-zeros(num_bootstrap_samples,1)
#td3_fd<-zeros(num_bootstrap_samples,1)
#td4_d<-zeros(num_bootstrap_samples,1)
#td4_fd<-zeros(num_bootstrap_samples,1)
#
## bootstrap loops
#set.seed(420)
#for (i in 1:num_bootstrap_samples){
#  # resample subjects instead of observations to be conserative
#	BootSubjs=sample(unique(mergedDf$Subjects),14,replace=T)
#	# Create an empty dataframe to store the resampled observations
#	bootSamp <- data.frame()
#	for (j in 1:length(BootSubjs)){
#		subject_obs <- meltedDf[meltedDf$Subjects == BootSubjs[j], ]
#		bootSamp <- rbind(bootSamp, subject_obs)
#	}
#  # fit model
#  model_i <- lme(value ~ MeanFD + Drug + RemTRs+variable+variable*Drug+variable*MeanFD, random = ~ 1 | Subjects/variable, data = bootSamp)
#  # get t-values
#  td1_d[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "Drug1:variableTDProp1", "t-value"]
#  td1_fd[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "MeanFD:variableTDProp1", "t-value"]
#  td3_d[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "Drug1:variableTDProp3", "t-value"]
#  td3_fd[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "MeanFD:variableTDProp3", "t-value"]
#  td4_d[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "Drug1:variableTDProp4", "t-value"]
#  td4_fd[i]=summary(model_i)$tTable[rownames(summary(model_i)$tTable) == "MeanFD:variableTDProp4", "t-value"]
#}
#
#bootstrap_results=data.frame(cbind(td1_d,td1_fd,td3_d,td3_fd,td4_d,td4_fd))
#colnames(bootstrap_results)=c('td1_drug','td1_fd','td3_drug','td3_fd','td4_drug','td4_fd')
#plotdf=melt(bootstrap_results)
#
## Create box-and-whisker plots
#ggplot(plotdf, aes(x = variable, y = value,)) +
#  geom_boxplot(position = position_dodge(width = 0.8)) +
#  labs(x = "Model", y = "T-Values", title = "Bootstrap T-Values for Drug and MeanFD") +
#  theme_minimal(base_size = 16)+scale_fill_manual(values=c('blue','red'))
```

```{r}
# complexity
rs1=read.csv('~/Downloads/rs1_complexityMerged(3).csv',header=F)
rs2=read.csv('~/Downloads/rs2_complexityMerged(3).csv',header=F)
emo=read.csv('~/Downloads/emotion_complexityMerged(3).csv',header=F)
gambling=read.csv('~/Downloads/gambling_complexityMerged(3).csv',header=F)
wm=read.csv('~/Downloads/wm_complexityMerged(3).csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V5))
rs1p=data.frame(cbind(rs1$V2,rs1$V6))
rs1m1=data.frame(cbind(rs1$V3,rs1$V7))
rs1m2=data.frame(cbind(rs1$V4,rs1$V8))
colnames(rs1bv)=c('Complexity','RemTRs')
colnames(rs1p)=c('Complexity','RemTRs')
colnames(rs1m1)=c('Complexity','RemTRs')
colnames(rs1m2)=c('Complexity','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V5))
rs2p=data.frame(cbind(rs2$V2,rs2$V6))
rs2m1=data.frame(cbind(rs2$V3,rs2$V7))
rs2m2=data.frame(cbind(rs2$V4,rs2$V8))
colnames(rs2bv)=c('Complexity','RemTRs')
colnames(rs2p)=c('Complexity','RemTRs')
colnames(rs2m1)=c('Complexity','RemTRs')
colnames(rs2m2)=c('Complexity','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V5))
emop=data.frame(cbind(emo$V2,emo$V6))
emom1=data.frame(cbind(emo$V3,emo$V7))
emom2=data.frame(cbind(emo$V4,emo$V8))
colnames(emobv)=c('Complexity','RemTRs')
colnames(emop)=c('Complexity','RemTRs')
colnames(emom1)=c('Complexity','RemTRs')
colnames(emom2)=c('Complexity','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V5))
gamblingp=data.frame(cbind(gambling$V2,gambling$V6))
gamblingm1=data.frame(cbind(gambling$V3,gambling$V7))
gamblingm2=data.frame(cbind(gambling$V4,gambling$V8))
colnames(gamblingbv)=c('Complexity','RemTRs')
colnames(gamblingp)=c('Complexity','RemTRs')
colnames(gamblingm1)=c('Complexity','RemTRs')
colnames(gamblingm2)=c('Complexity','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V5))
wmp=data.frame(cbind(wm$V2,wm$V6))
wmm1=data.frame(cbind(wm$V3,wm$V7))
wmm2=data.frame(cbind(wm$V4,wm$V8))
colnames(wmbv)=c('Complexity','RemTRs')
colnames(wmp)=c('Complexity','RemTRs')
colnames(wmm1)=c('Complexity','RemTRs')
colnames(wmm2)=c('Complexity','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# comibine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf=mergedDf[mergedDf$Dosage!='baseline',]
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)

mergedDfPropsCompl=merge(mergedDfProps,mergedDf,by=c("Subjects","Task","Dosage","Session","MeanFD","SpikesPercent","RemTRs","Drug"))

```

```{r}
# autocorrelation
rs1=read.csv('~/Downloads/rs1_TAutoCorMerged.csv',header=F)
rs2=read.csv('~/Downloads/rs2_TAutoCorMerged.csv',header=F)
emo=read.csv('~/Downloads/emotion_TAutoCorMerged.csv',header=F)
gambling=read.csv('~/Downloads/gambling_TAutoCorMerged.csv',header=F)
wm=read.csv('~/Downloads/wm_TAutoCorMerged.csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V5))
rs1p=data.frame(cbind(rs1$V2,rs1$V6))
rs1m1=data.frame(cbind(rs1$V3,rs1$V7))
rs1m2=data.frame(cbind(rs1$V4,rs1$V8))
colnames(rs1bv)=c('AutoCor','RemTRs')
colnames(rs1p)=c('AutoCor','RemTRs')
colnames(rs1m1)=c('AutoCor','RemTRs')
colnames(rs1m2)=c('AutoCor','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V5))
rs2p=data.frame(cbind(rs2$V2,rs2$V6))
rs2m1=data.frame(cbind(rs2$V3,rs2$V7))
rs2m2=data.frame(cbind(rs2$V4,rs2$V8))
colnames(rs2bv)=c('AutoCor','RemTRs')
colnames(rs2p)=c('AutoCor','RemTRs')
colnames(rs2m1)=c('AutoCor','RemTRs')
colnames(rs2m2)=c('AutoCor','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V5))
emop=data.frame(cbind(emo$V2,emo$V6))
emom1=data.frame(cbind(emo$V3,emo$V7))
emom2=data.frame(cbind(emo$V4,emo$V8))
colnames(emobv)=c('AutoCor','RemTRs')
colnames(emop)=c('AutoCor','RemTRs')
colnames(emom1)=c('AutoCor','RemTRs')
colnames(emom2)=c('AutoCor','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V5))
gamblingp=data.frame(cbind(gambling$V2,gambling$V6))
gamblingm1=data.frame(cbind(gambling$V3,gambling$V7))
gamblingm2=data.frame(cbind(gambling$V4,gambling$V8))
colnames(gamblingbv)=c('AutoCor','RemTRs')
colnames(gamblingp)=c('AutoCor','RemTRs')
colnames(gamblingm1)=c('AutoCor','RemTRs')
colnames(gamblingm2)=c('AutoCor','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V5))
wmp=data.frame(cbind(wm$V2,wm$V6))
wmm1=data.frame(cbind(wm$V3,wm$V7))
wmm2=data.frame(cbind(wm$V4,wm$V8))
colnames(wmbv)=c('AutoCor','RemTRs')
colnames(wmp)=c('AutoCor','RemTRs')
colnames(wmm1)=c('AutoCor','RemTRs')
colnames(wmm2)=c('AutoCor','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# comibine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf=mergedDf[mergedDf$Dosage!='baseline',]
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)
```

```{r}
# combine complexity and props and autocor
mergedDfPropsComplAutoC=merge(mergedDfPropsCompl,mergedDf,by=c("Subjects","Task","Dosage","Session","MeanFD","SpikesPercent","RemTRs","Drug"))
```

```{r}
# DMN seg
rs1=read.csv('~/Downloads/rs1_DMNSegMerged.csv',header=F)
rs2=read.csv('~/Downloads/rs2_DMNSegMerged.csv',header=F)
emo=read.csv('~/Downloads/emotion_DMNSegMerged.csv',header=F)
gambling=read.csv('~/Downloads/gambling_DMNSegMerged.csv',header=F)
wm=read.csv('~/Downloads/wm_DMNSegMerged.csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V5))
rs1p=data.frame(cbind(rs1$V2,rs1$V6))
rs1m1=data.frame(cbind(rs1$V3,rs1$V7))
rs1m2=data.frame(cbind(rs1$V4,rs1$V8))
colnames(rs1bv)=c('DMNFC','RemTRs')
colnames(rs1p)=c('DMNFC','RemTRs')
colnames(rs1m1)=c('DMNFC','RemTRs')
colnames(rs1m2)=c('DMNFC','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V5))
rs2p=data.frame(cbind(rs2$V2,rs2$V6))
rs2m1=data.frame(cbind(rs2$V3,rs2$V7))
rs2m2=data.frame(cbind(rs2$V4,rs2$V8))
colnames(rs2bv)=c('DMNFC','RemTRs')
colnames(rs2p)=c('DMNFC','RemTRs')
colnames(rs2m1)=c('DMNFC','RemTRs')
colnames(rs2m2)=c('DMNFC','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V5))
emop=data.frame(cbind(emo$V2,emo$V6))
emom1=data.frame(cbind(emo$V3,emo$V7))
emom2=data.frame(cbind(emo$V4,emo$V8))
colnames(emobv)=c('DMNFC','RemTRs')
colnames(emop)=c('DMNFC','RemTRs')
colnames(emom1)=c('DMNFC','RemTRs')
colnames(emom2)=c('DMNFC','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V5))
gamblingp=data.frame(cbind(gambling$V2,gambling$V6))
gamblingm1=data.frame(cbind(gambling$V3,gambling$V7))
gamblingm2=data.frame(cbind(gambling$V4,gambling$V8))
colnames(gamblingbv)=c('DMNFC','RemTRs')
colnames(gamblingp)=c('DMNFC','RemTRs')
colnames(gamblingm1)=c('DMNFC','RemTRs')
colnames(gamblingm2)=c('DMNFC','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V5))
wmp=data.frame(cbind(wm$V2,wm$V6))
wmm1=data.frame(cbind(wm$V3,wm$V7))
wmm2=data.frame(cbind(wm$V4,wm$V8))
colnames(wmbv)=c('DMNFC','RemTRs')
colnames(wmp)=c('DMNFC','RemTRs')
colnames(wmm1)=c('DMNFC','RemTRs')
colnames(wmm2)=c('DMNFC','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# comibine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf=mergedDf[mergedDf$Dosage!='baseline',]
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)

```

```{r}
# combine complexity and props and autocor
mergedDfPropsComplAutoCdmnFC=merge(mergedDfPropsComplAutoC,mergedDf,by=c("Subjects","Task","Dosage","Session","MeanFD","SpikesPercent","RemTRs","Drug"))
```

```{r}
# DMN mag
rs1=read.csv('~/Downloads/rs1_DMNMagMerged.csv',header=F)
rs2=read.csv('~/Downloads/rs2_DMNMagMerged.csv',header=F)
emo=read.csv('~/Downloads/emotion_DMNMagMerged.csv',header=F)
gambling=read.csv('~/Downloads/gambling_DMNMagMerged.csv',header=F)
wm=read.csv('~/Downloads/wm_DMNMagMerged.csv',header=F)
# set colnames
#colnames(rs1)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(rs2)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(emo)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(gambling)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
#colnames(wm)=c('bvProp','pProp','m1Prop','m2Prop','bvTRs','pTRs','m1TRs','m2TRs')
rs1$Task='rs'
rs2$Task='rs2'
emo$Task='emotion'
gambling$Task='gambling'
wm$Task='wm'

# remove subj 4
rs1=rs1[-c(4),]
rs2=rs2[-c(4),]
emo=emo[-c(4),]
gambling=gambling[-c(4),]
wm=wm[-c(4),]

# this is going to be ugly but simple
# manually pair columns as sep. observations of baseline, placebo, 80, 120mg
rs1bv=data.frame(cbind(rs1$V1,rs1$V5))
rs1p=data.frame(cbind(rs1$V2,rs1$V6))
rs1m1=data.frame(cbind(rs1$V3,rs1$V7))
rs1m2=data.frame(cbind(rs1$V4,rs1$V8))
colnames(rs1bv)=c('DMNMag','RemTRs')
colnames(rs1p)=c('DMNMag','RemTRs')
colnames(rs1m1)=c('DMNMag','RemTRs')
colnames(rs1m2)=c('DMNMag','RemTRs')

rs2bv=data.frame(cbind(rs2$V1,rs2$V5))
rs2p=data.frame(cbind(rs2$V2,rs2$V6))
rs2m1=data.frame(cbind(rs2$V3,rs2$V7))
rs2m2=data.frame(cbind(rs2$V4,rs2$V8))
colnames(rs2bv)=c('DMNMag','RemTRs')
colnames(rs2p)=c('DMNMag','RemTRs')
colnames(rs2m1)=c('DMNMag','RemTRs')
colnames(rs2m2)=c('DMNMag','RemTRs')

emobv=data.frame(cbind(emo$V1,emo$V5))
emop=data.frame(cbind(emo$V2,emo$V6))
emom1=data.frame(cbind(emo$V3,emo$V7))
emom2=data.frame(cbind(emo$V4,emo$V8))
colnames(emobv)=c('DMNMag','RemTRs')
colnames(emop)=c('DMNMag','RemTRs')
colnames(emom1)=c('DMNMag','RemTRs')
colnames(emom2)=c('DMNMag','RemTRs')

gamblingbv=data.frame(cbind(gambling$V1,gambling$V5))
gamblingp=data.frame(cbind(gambling$V2,gambling$V6))
gamblingm1=data.frame(cbind(gambling$V3,gambling$V7))
gamblingm2=data.frame(cbind(gambling$V4,gambling$V8))
colnames(gamblingbv)=c('DMNMag','RemTRs')
colnames(gamblingp)=c('DMNMag','RemTRs')
colnames(gamblingm1)=c('DMNMag','RemTRs')
colnames(gamblingm2)=c('DMNMag','RemTRs')

wmbv=data.frame(cbind(wm$V1,wm$V5))
wmp=data.frame(cbind(wm$V2,wm$V6))
wmm1=data.frame(cbind(wm$V3,wm$V7))
wmm2=data.frame(cbind(wm$V4,wm$V8))
colnames(wmbv)=c('DMNMag','RemTRs')
colnames(wmp)=c('DMNMag','RemTRs')
colnames(wmm1)=c('DMNMag','RemTRs')
colnames(wmm2)=c('DMNMag','RemTRs')

# get subject IDs from this rds
alff=readRDS('~/OutPlacDrug_alff.rds')
rs1bv$Subjects=alff$SubjID
rs1p$Subjects=alff$SubjID
rs1m1$Subjects=alff$SubjID
rs1m2$Subjects=alff$SubjID

rs2bv$Subjects=alff$SubjID
rs2p$Subjects=alff$SubjID
rs2m1$Subjects=alff$SubjID
rs2m2$Subjects=alff$SubjID

emobv$Subjects=alff$SubjID
emop$Subjects=alff$SubjID
emom1$Subjects=alff$SubjID
emom2$Subjects=alff$SubjID

gamblingbv$Subjects=alff$SubjID
gamblingp$Subjects=alff$SubjID
gamblingm1$Subjects=alff$SubjID
gamblingm2$Subjects=alff$SubjID

wmbv$Subjects=alff$SubjID
wmp$Subjects=alff$SubjID
wmm1$Subjects=alff$SubjID
wmm2$Subjects=alff$SubjID

# add in task (rs to be made equivalent after motion merge)
rs1bv$Task='rs'
rs1p$Task='rs'
rs1m1$Task='rs'
rs1m2$Task='rs'

rs2bv$Task='rs2'
rs2p$Task='rs2'
rs2m1$Task='rs2'
rs2m2$Task='rs2'

emobv$Task='emotion'
emop$Task='emotion'
emom1$Task='emotion'
emom2$Task='emotion'

gamblingbv$Task='gambling'
gamblingp$Task='gambling'
gamblingm1$Task='gambling'
gamblingm2$Task='gambling'

wmbv$Task='wm'
wmp$Task='wm'
wmm1$Task='wm'
wmm2$Task='wm'

# add in dosage
rs1bv$Dosage='baseline'
rs1p$Dosage='Placebo'
rs1m1$Dosage='80mg'
rs1m2$Dosage='120mg'

rs2bv$Dosage='baseline'
rs2p$Dosage='Placebo'
rs2m1$Dosage='80mg'
rs2m2$Dosage='120mg'

emobv$Dosage='baseline'
emop$Dosage='Placebo'
emom1$Dosage='80mg'
emom2$Dosage='120mg'

gamblingbv$Dosage='baseline'
gamblingp$Dosage='Placebo'
gamblingm1$Dosage='80mg'
gamblingm2$Dosage='120mg'

wmbv$Dosage='baseline'
wmp$Dosage='Placebo'
wmm1$Dosage='80mg'
wmm2$Dosage='120mg'

# comibine all
allScans=rbind(rs1bv,rs1p,rs1m1,rs1m2,rs2bv,rs2p,rs2m1,rs2m2,emobv,emop,emom1,emom2,gamblingbv,gamblingp,gamblingm1,gamblingm2,wmbv,wmp,wmm1,wmm2)

# read in motion
mot=read.csv('~/Desktop/MDMA_spikes_summary.csv')

# motion merge
mergedDf=merge(mot,allScans,by=c('Subjects','Task','Dosage'))
mergedDf=mergedDf[mergedDf$Dosage!='baseline',]
mergedDf$Drug=0
mergedDf$Drug[mergedDf$Dosage=="120mg"]=1
mergedDf$Drug[mergedDf$Dosage=="80mg"]=1
mergedDf$Drug=as.factor(mergedDf$Drug)

```

```{r}
# combine complexity and props and autocor
mergedDfPropsComplAutoCdmnFCdmnMag=merge(mergedDfPropsComplAutoCdmnFC,mergedDf,by=c("Subjects","Task","Dosage","Session","MeanFD","SpikesPercent","RemTRs","Drug"))
```

```{r}
# remove data that needs to be removed (subs 6 and 10, <250 TRs)
mergedDfPropsComplAutoCdmnFCdmnMag=mergedDfPropsComplAutoCdmnFCdmnMag[mergedDfPropsComplAutoCdmnFCdmnMag$Subjects!='sub-MDMA006',]
mergedDfPropsComplAutoCdmnFCdmnMag=mergedDfPropsComplAutoCdmnFCdmnMag[mergedDfPropsComplAutoCdmnFCdmnMag$Subjects!='sub-MDMA010',]
mergedDfPropsComplAutoCdmnFCdmnMag=mergedDfPropsComplAutoCdmnFCdmnMag[mergedDfPropsComplAutoCdmnFCdmnMag$RemTRs>250,]

# change rs2 to rs for accurate task-modeling
mergedDfPropsComplAutoCdmnFCdmnMag$Task[mergedDfPropsComplAutoCdmnFCdmnMag$Task=='rs2']='rs'
mergedDfPropsComplAutoCdmnFCdmnMag$Task=as.factor(mergedDfPropsComplAutoCdmnFCdmnMag$Task)

# set rs to reference level
mergedDfPropsComplAutoCdmnFCdmnMag <- within(mergedDfPropsComplAutoCdmnFCdmnMag, Task <- relevel(Task, ref = 2))

# model
td_model <- lme(TDProp1 ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
ta_model <- lme(AutoCor ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
cx_model <- lme(Complexity ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
dmnseg_model <- lme(DMNFC ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
dmnmag_model <- lme(DMNMag ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)

# for correlation matrix
forCormat=data.frame(mergedDfPropsComplAutoCdmnFCdmnMag$TDProp1,mergedDfPropsComplAutoCdmnFCdmnMag$AutoCor,mergedDfPropsComplAutoCdmnFCdmnMag$Complexity,mergedDfPropsComplAutoCdmnFCdmnMag$DMNFC,mergedDfPropsComplAutoCdmnFCdmnMag$MeanFD,mergedDfPropsComplAutoCdmnFCdmnMag$RemTRs,mergedDfPropsComplAutoCdmnFCdmnMag$DMNMag)

colnames(forCormat)=c('TDProp1','AutoCor','Complexity','DMNFC','MeanFD','RemTRs','DMNMag')

library(corrplot)
source("http://www.sthda.com/upload/rquery_cormat.r")

corrmatrix=rquery.cormat(forCormat,type="full")
corrplot(as.matrix(corrmatrix$r),method='number')

# need to establish which DMN metrics are associated above and beyond drug effect
# DMN FC
dmnseg_model <- lme(DMNFC ~ MeanFD + Drug+RemTRs+Task+TDProp1+AutoCor+DMNMag, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
# DMN tdprops
td_model <- lme(TDProp1 ~ MeanFD + Drug+RemTRs+Task+DMNFC+AutoCor+DMNMag, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
# DMN Mag
dmnmag_model <- lme(DMNMag ~ MeanFD + Drug+RemTRs+Task+DMNFC+AutoCor+TDProp1, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
# DMN autocor
dmnAC_model <- lme(AutoCor ~ MeanFD + Drug+RemTRs+Task+DMNFC+DMNMag+TDProp1, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)

library(pROC)
library(plotROC)
mergedDfPropsComplAutoCdmnFCdmnMag_notask=mergedDfPropsComplAutoCdmnFCdmnMag[mergedDfPropsComplAutoCdmnFCdmnMag$Task=='rs',]
# Fit logistic regression models
model1 <- glm(Drug ~ MeanFD + RemTRs + DMNFC+AutoCor, data = mergedDfPropsComplAutoCdmnFCdmnMag_notask, family = binomial)
model2 <- glm(Drug ~ MeanFD + RemTRs + DMNFC + AutoCor+DMNMag+TDProp1, data = mergedDfPropsComplAutoCdmnFCdmnMag_notask, family = binomial)

# Predict probabilities
prob1 <- predict(model1, type = "response")
prob2 <- predict(model2, type = "response")

# Create a combined data frame for all models
df <- data.frame(
  labels = as.numeric(rep(mergedDfPropsComplAutoCdmnFCdmnMag_notask$Drug, 2)),
  predictions = c(prob1, prob2),
  model = factor(rep(c("DMN Correlations", "+DMN Propagations"), each = nrow(mergedDfPropsComplAutoCdmnFCdmnMag_notask)))
)

# Generate the ROC plot
ggplot(df, aes(m = predictions, d = labels, color = model)) + 
  geom_roc(n.cuts = 0, labels = FALSE) + 
  ylim(0, 1) + ylab('True Positive Rate') +xlab('False Positive Rate')+
  ggtitle("ROC Curves for Predicting MDMA") + 
  theme_minimal(base_size=18) + 
  scale_color_manual(values = c("#09416b","#c12139"))+
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray")+
  theme(legend.position = "none")


# Calculate AUC for each model
roc1 <- roc(mergedDfPropsComplAutoCdmnFCdmnMag_notask$Drug, prob1)
roc2 <- roc(mergedDfPropsComplAutoCdmnFCdmnMag_notask$Drug, prob2)

# Print AUC values
auc1 <- auc(roc1)
auc2 <- auc(roc2)


print(paste("AUC for DMN Correlations:", auc1))
print(paste("AUC for Full Model:", auc2))

# Calculate AUC difference between full and reduced models
auc_diff <- auc2 - auc1
```

```{r}
# Temporary comment out: output is making rstudio wonky




# make equivalent AUC calculations on permuted data
# initialize AUC difference vectors
#auc_diffs <- rep(NA, 1000)
#
## 1. permute each DMN variable (and FD)
#set.seed(1)
#for (i in 1:1000){
#  print(i)
#  # permute DMNMag
#  mergedDfPropsComplAutoCdmnFCdmnMag_notask$DMNMag_perm <- sample(mergedDfPropsComplAutoCdmnFCdmnMag_notask$DMNMag)
#  # permute TDProp1
#  mergedDfPropsComplAutoCdmnFCdmnMag_notask$TDProp1_perm <- sample(mergedDfPropsComplAutoCdmnFCdmnMag_notask$TDProp1)
# 
#  # Fit logistic regression models
#  model1 <- glm(Drug ~ MeanFD + RemTRs + DMNFC+AutoCor, data = mergedDfPropsComplAutoCdmnFCdmnMag_notask, family = #binomial)
#  model2_perm <- glm(Drug ~ MeanFD + RemTRs + DMNFC+AutoCor+TDProp1_perm+DMNMag_perm, data = #mergedDfPropsComplAutoCdmnFCdmnMag_notask, family = binomial)
#	
#  # 3. calculate AUC difference between full and reduced models with permuted data
#  roc1 <- roc(mergedDfPropsComplAutoCdmnFCdmnMag_notask$Drug, predict(model1, type = "response"))
#  roc2_perm <- roc(mergedDfPropsComplAutoCdmnFCdmnMag_notask$Drug, predict(model2_perm, type = "response"))
#  
#  # Print AUC values
#  auc1 <- auc(roc1)
#  auc2_perm <-auc(roc2_perm)
#
#  # populate auc_diff vectors
#  # DMN correlations vs. full (permuted props) model
#  auc_diffs[i] <- auc1 - auc2_perm
#}
## 4. Compare true AUC differences to permuted AUC differences
#
#sum(auc_diffs>auc_diff)
# 0 indicates p <0.001
```

```{r}
# partial correlations
# Install and load necessary packages
#install.packages("ppcor")
library(ppcor)

# Create your data frame
forCormat <- data.frame(
  TDProp1 = mergedDfPropsComplAutoCdmnFCdmnMag$TDProp1,
  AutoCor = mergedDfPropsComplAutoCdmnFCdmnMag$AutoCor,
  Complexity = mergedDfPropsComplAutoCdmnFCdmnMag$Complexity,
  DMNFC = mergedDfPropsComplAutoCdmnFCdmnMag$DMNFC,
  MeanFD = mergedDfPropsComplAutoCdmnFCdmnMag$MeanFD,
  RemTRs = mergedDfPropsComplAutoCdmnFCdmnMag$RemTRs,
  DMNMag = mergedDfPropsComplAutoCdmnFCdmnMag$DMNMag
)

colnames(forCormat) <- c('TDProp1', 'AutoCor', 'Complexity', 'DMNFC', 'MeanFD', 'RemTRs', 'DMNMag')

# Compute the partial correlation matrix
partial_corr <- pcor(forCormat)$estimate
colnames(partial_corr)<-colnames(forCormat)
rownames(partial_corr)<-colnames(forCormat)
# Visualize the partial correlation matrix using corrplot
corrplot(partial_corr,method='number')
```

```{r}
# complexity plot

# preproc for plot
mergedDfPropsComplAutoCdmnFCdmnMag$Drug=0
mergedDfPropsComplAutoCdmnFCdmnMag$Drug[mergedDfPropsComplAutoCdmnFCdmnMag$Dosage=="120mg"]=1
mergedDfPropsComplAutoCdmnFCdmnMag$Drug[mergedDfPropsComplAutoCdmnFCdmnMag$Dosage=="80mg"]=1
mergedDfPropsComplAutoCdmnFCdmnMag$Drug=as.factor(mergedDfPropsComplAutoCdmnFCdmnMag$Drug)
mergedDfPropsComplAutoCdmnFCdmnMag$Subjects<-as.factor(mergedDfPropsComplAutoCdmnFCdmnMag$Subjects)
mergedDfPropsComplAutoCdmnFCdmnMag$Dosage<-as.factor(mergedDfPropsComplAutoCdmnFCdmnMag$Dosage)
# change rs2 to rs for accurate task-modeling
mergedDfPropsComplAutoCdmnFCdmnMag$Task[mergedDfPropsComplAutoCdmnFCdmnMag$Task=='rs2']='rs'
mergedDfPropsComplAutoCdmnFCdmnMag$Task=as.factor(mergedDfPropsComplAutoCdmnFCdmnMag$Task)
df_plot1=mergedDfPropsComplAutoCdmnFCdmnMag[mergedDfPropsComplAutoCdmnFCdmnMag$Dosage!="120mg",]
# for p-120
df_plot2=mergedDfPropsComplAutoCdmnFCdmnMag[mergedDfPropsComplAutoCdmnFCdmnMag$Dosage!="80mg",]
df_plot1$SubjectTask <- interaction(df_plot1$Subjects, df_plot1$Task)
df_plot2$SubjectTask <- interaction(df_plot2$Subjects, df_plot2$Task)

# Plotting
ggplot(df_plot1, aes(x = Drug, y = Complexity, fill = Drug, group = SubjectTask, color = Subjects)) +
  geom_point(size = 4, aes(alpha = 0.7)) +
  geom_line() +
  geom_point(data = df_plot2, aes(color = Subjects,alpha=.7), size = 4) +
  geom_line(data = df_plot2, aes(group = SubjectTask, color = Subjects)) +
  scale_color_viridis_d(option = "plasma") +
  ggtitle('All Scans') +
  theme_minimal(base_size = 22)

# by task
ggplot(mergedDfPropsComplAutoCdmnFCdmnMag, aes(x = Task, y = Complexity)) +
  geom_boxplot(size = 1, aes(alpha = 0.7)) +
  ggtitle('All Scans') +
  theme_minimal(base_size = 22)

cx_task_model <- lme(Complexity ~ MeanFD + Drug+Task+RemTRs, random = ~ 1 | Subjects, data = mergedDfPropsComplAutoCdmnFCdmnMag)
```

```{r}
# briefly demonstrate lack of relationship between complexity and BUP, can consider using residuals (contr for motion + task)
ggplot(mergedDfPropsComplAutoCdmnFCdmnMag,aes(x=Complexity,y=TDProp1))+geom_point()+theme_minimal(base_size=25)+ylab('Bottom-up %')
```

```{r}
# extract standout sessions/participants for COMPLEXITY this time
# Calculate the difference in Complexity between Drug and Placebo conditions
df_diff <- mergedDfPropsComplAutoCdmnFCdmnMag %>%
  group_by(Subjects) %>%
  summarise(Diff_Compl = mean(Complexity[Drug == 1]) - mean(Complexity[Drug == 0], na.rm = TRUE))

# Identify the participant with the greatest increase in Complexity
max_diff_subject <- df_diff %>%
  filter(Diff_Compl == max(Diff_Compl, na.rm = TRUE)) %>%
  pull(Subjects)


print(max_diff_subject)

```

```{r}
# great, now let's bootstrap them
# Set the number of bootstrap samples
num_bootstrap_samples <- 1000
# initialize t vectors
td_d<-rep(0,num_bootstrap_samples)
td_fd<-rep(0,num_bootstrap_samples)
ta_d<-rep(0,num_bootstrap_samples)
ta_fd<-rep(0,num_bootstrap_samples)
cx_d<-rep(0,num_bootstrap_samples)
cx_fd<-rep(0,num_bootstrap_samples)
ds_d<-rep(0,num_bootstrap_samples)
ds_fd<-rep(0,num_bootstrap_samples)
dm_d<-rep(0,num_bootstrap_samples)
dm_fd<-rep(0,num_bootstrap_samples)

# bootstrap loops
set.seed(1)
for (i in 1:num_bootstrap_samples){
  # resample data
  data=mergedDfPropsComplAutoCdmnFCdmnMag[sample(nrow(mergedDfPropsComplAutoCdmnFCdmnMag), replace = TRUE), ]
  # fit on all models
  td_model <- lme(TDProp1 ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = data)
  ta_model <- lme(AutoCor ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = data)
  cx_model <- lme(Complexity ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = data)
  ds_model <- lme(DMNFC ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = data)
  dm_model <- lme(DMNMag ~ MeanFD + Drug+RemTRs+Task, random = ~ 1 | Subjects, data = data)
  # get t-values
  td_d[i]=summary(td_model)$tTable[rownames(summary(td_model)$tTable) == "Drug1", "t-value"]
  td_fd[i]=summary(td_model)$tTable[rownames(summary(td_model)$tTable) == "MeanFD", "t-value"]
  ta_d[i]=summary(ta_model)$tTable[rownames(summary(ta_model)$tTable) == "Drug1", "t-value"]
  ta_fd[i]=summary(ta_model)$tTable[rownames(summary(ta_model)$tTable) == "MeanFD", "t-value"]
  cx_d[i]=summary(cx_model)$tTable[rownames(summary(cx_model)$tTable) == "Drug1", "t-value"]
  cx_fd[i]=summary(cx_model)$tTable[rownames(summary(cx_model)$tTable) == "MeanFD", "t-value"]
  ds_d[i]=summary(ds_model)$tTable[rownames(summary(ds_model)$tTable) == "Drug1", "t-value"]
  ds_fd[i]=summary(ds_model)$tTable[rownames(summary(ds_model)$tTable) == "MeanFD", "t-value"]
  dm_d[i]=summary(dm_model)$tTable[rownames(summary(dm_model)$tTable) == "Drug1", "t-value"]
  dm_fd[i]=summary(dm_model)$tTable[rownames(summary(dm_model)$tTable) == "MeanFD", "t-value"]
}
# convert to dataframes
td_d=data.frame(td_d)
ta_d=data.frame(ta_d)
cx_d=data.frame(cx_d)
ds_d=data.frame(ds_d)
dm_d=data.frame(dm_d)
td_fd=data.frame(td_fd)
ta_fd=data.frame(ta_fd)
cx_fd=data.frame(cx_fd)
ds_fd=data.frame(ds_fd)
dm_fd=data.frame(dm_fd)

colnames(td_d)='tstat'
colnames(ta_d)='tstat'
colnames(cx_d)='tstat'
colnames(ds_d)='tstat'
colnames(dm_d)='tstat'
colnames(td_fd)='tstat'
colnames(ta_fd)='tstat'
colnames(cx_fd)='tstat'
colnames(ds_fd)='tstat'
colnames(dm_fd)='tstat'

# set column names for merging
td_d$Cov='Drug'
ta_d$Cov='Drug'
cx_d$Cov='Drug'
ds_d$Cov='Drug'
dm_d$Cov='Drug'

td_fd$Cov='FD'
ta_fd$Cov='FD'
cx_fd$Cov='FD'
ds_fd$Cov='FD'
dm_fd$Cov='FD'

td_d$Model='Bottom-up %'
ta_d$Model='AutoCor'
cx_d$Model='Complexity'
ds_d$Model='Integration'
dm_d$Model='Magnitude'

td_fd$Model='Bottom-up %'
ta_fd$Model='AutoCor'
cx_fd$Model='Complexity'
ds_fd$Model='Integration'
dm_fd$Model='Magnitude'

bootstrap_results_FD=rbind(td_fd,ta_fd,ds_fd,dm_fd)
bootstrap_results_Drug=rbind(td_d,ta_d,ds_d,dm_d)
# Calculate the average t-value for each Model category
average_t_values <- bootstrap_results_FD %>%
  group_by(Model) %>%
  summarize(avg_t_value = mean(abs(tstat), na.rm = TRUE))

# Reorder the Model factor based on the average t-values
bootstrap_results_FD$Model <- factor(bootstrap_results_FD$Model, 
                                     levels = average_t_values$Model[order(average_t_values$avg_t_value)])


# Calculate the average t-value for each Model category
average_t_values <- bootstrap_results_Drug %>%
  group_by(Model) %>%
  summarize(avg_t_value = mean(abs(tstat), na.rm = TRUE))

# Reorder the Model factor based on the average t-values
bootstrap_results_Drug$Model <- factor(bootstrap_results_Drug$Model, 
                                     levels = average_t_values$Model[order(average_t_values$avg_t_value)])

library(ggdist)
# Generate the plot
ggplot(bootstrap_results_FD, aes(x = Model, y = tstat, fill = Cov)) +
    geom_boxplot(
        width = 0.12,
        # Removing outliers
        outlier.color = NA,
        fill='#EF9500'
    ) +
    stat_dots(
        # Plotting on left side
        side = "left",
        # Adjusting position
        justification = 1.1,
        # Adjust grouping (binning) of observations
        binwidth = 0.08
    ) +
    labs(x = "Model", y = "T-Values", title = "Bootstrap T-Values for FD effect") +
    theme_minimal(base_size = 18) +
    geom_hline(yintercept = 0, linetype = "dashed")+
    # just to prevent extra x-axis expansion
    coord_cartesian(xlim = c(.8, length(unique(bootstrap_results_Drug$Model))))+
    theme(legend.position = "none")



# Calculate the average t-value for each Model category
average_t_values <- bootstrap_results_Drug %>%
  group_by(Model) %>%
  summarize(avg_t_value = mean(tstat, na.rm = TRUE))

# Reorder the Model factor based on the average t-values
bootstrap_results_Drug$Model <- factor(bootstrap_results_Drug$Model, 
                                     levels = c('Integration','AutoCor','Bottom-up %','Magnitude'))


# add fill column
bootstrap_results_Drug$Fill='DMN Correlatons'
bootstrap_results_Drug$Fill[bootstrap_results_Drug$Model=='Bottom-up %']='DMN Propagations'
bootstrap_results_Drug$Fill[bootstrap_results_Drug$Model=='Magnitude']='DMN Propagations'


# Generate the plot
ggplot(bootstrap_results_Drug, aes(x = Model, y = tstat, fill = Fill)) +
    geom_boxplot(
        width = 0.12,
        # Removing outliers
        outlier.color = NA) +
        scale_fill_manual(values=c("#c12139","#09416b"))+
    stat_dots(
        # Plotting on left side
        side = "left",
        # Adjusting position
        justification = 1.1,
        # Adjust grouping (binning) of observations
        binwidth = 0.08,
        overflow = "compress"
    ) +
    labs(x = "Model", y = "T-Values", title = "Bootstrap T-Values for MDMA effect") +
    theme_minimal(base_size = 18) +
    geom_hline(yintercept = 0, linetype = "dashed")+
    # just to prevent extra x-axis expansion
    coord_cartesian(xlim = c(1, length(unique(bootstrap_results_Drug$Model))))+
    theme(legend.position = "none")+ylim(c(-10.5,10.5))

```


```{r}
# now compare with VAS
vas=read.csv('~/Downloads/MDMA_VAS_ASC_forAdam_03062023.csv')
# correct subject naming
vas$Subjects <- paste0("sub-MDMA", sprintf("%03d", vas$Subjects))
VASmerge=merge(vas,mergedDfPropsComplAutoCdmnFCdmnMag,by=c("Subjects","Dosage"))

# and add in CADSS
cadss=read.csv('~/Downloads/MDMA_Questionnaires_Post-Pre_RepeatedMeasures_Pervisit.csv')
cadss$Subjects <- paste0("sub-MDMA", sprintf("%03d", cadss$Subjects))
cadss=merge(cadss,VASmerge,by=c("Subjects","Dosage"))


# and add in dissoc measure from SSV
dissoc=read.csv('~/Downloads/P50MDMA-5ASC_DATA_2024-07-09_0846_wDissoc.csv')
dissoc$Subjects <- paste0("sub-MDMA", sprintf("%03d", dissoc$Subjects))
dissoc=merge(dissoc,VASmerge,by=c("Subjects","Session"))

# model cadss and SSV dissoc measures
model<-lme(TDProp1 ~ CADSS_post_pre + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = cadss)
model<-lme(TDProp1 ~ dascscore_dissociation_SV_normed + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = dissoc)

```

```{r}
## and amygdalar reactivity baseline
#AmygB=data.frame(c(1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17),c(-0.872159019,-1.613577432,-0.148527068,0.903748312,0.87746#1373,0.710832929,0.436758886,0.599261478,0.112770896,1.541066765,-1.393745839,-0.302041457,1.8678551,0.690276024,-0.8057#38997,1.514496002))
#
#colnames(AmygB)=c('Subjects','BaselineAmygReact')
#AmygB$Subjects<-AmygB$Subjects <- paste0("sub-MDMA", sprintf("%03d", AmygB$Subjects))
#
## merged
#mergedAmyg=merge(AmygB,mergedDfPropsComplAutoCdmnFCdmnMag,by='Subjects')
#
## test
#TD_int=lme(TDProp1 ~ MeanFD + Drug*BaselineAmygReact+RemTRs+Task, random = ~ 1 | Subjects, data = mergedAmyg)
#Compl_int=lme(Complexity ~ MeanFD + Drug*BaselineAmygReact+RemTRs+Task, random = ~ 1 | Subjects, data = mergedAmyg)
#TA_int=lme(AutoCor ~ MeanFD + Drug*BaselineAmygReact+RemTRs+Task, random = ~ 1 | Subjects, data = mergedAmyg)
#DMNS_int=lme(DMNFC ~ MeanFD + Drug*BaselineAmygReact+RemTRs+Task, random = ~ 1 | Subjects, data = mergedAmyg)
#DMNMag_int=lme(DMNMag ~ MeanFD + Drug*BaselineAmygReact+RemTRs+Task, random = ~ 1 | Subjects, data = mergedAmyg)
#
#library(sjPlot)
#plot_model(TD_int,type='int',title='% bottom-up by baseline \n amygdalar reactivity')
#plot_model(Compl_int,type='int',title='complexity by baseline \n amygdalar reactivity')
#plot_model(TA_int,type='int',title='AutoCor by baseline \n amygdalar reactivity')
#plot_model(DMNS_int,type='int',title='DMN FC by baseline \n amygdalar reactivity')
#plot_model(DMNMag_int,type='int',title='DMN Magnitude by baseline \n amygdalar reactivity')
```


```{r}
###### spin tests
# load in y7 alignment left
y7align_L=read.csv('~/Downloads/perm_vs_obs_DMN_Y7_L.csv')
y7align_R=read.csv('~/Downloads/perm_vs_obs_DMN_Y7_R.csv')
# add a real vs. permuted value
y7align_L$Observed=0
y7align_R$Observed=0
y7align_L$Observed[10001]=1
y7align_R$Observed[10001]=1
# add right vs. left
y7align_L$Side='Left'
y7align_R$Side='Right'
y7plotdf=rbind(y7align_L,y7align_R)

# subset spun and nonspun df
spunL=y7align_L[1:10000,]
ObsL=y7align_L[10001,]
spunR=y7align_R[1:10000,]
ObsR=y7align_R[10001,]
  
# left hemi
ggplot(spunL,aes(x=Var1))+geom_density(size=1.5)+geom_vline(xintercept = ObsL$Var1,size=2,color='#BC3754')+theme_classic(base_size=23)+ylab('')+xlab('T-Statistics')+guides(y="none")+theme(axis.text = element_text(size=22))+ggtitle('DMN localization to Yeo7 Boundary: Left hemisphere')

# right hemi
ggplot(spunR,aes(x=Var1))+geom_density(size=1.5)+geom_vline(xintercept = ObsR$Var1,size=2,color='#BC3754')+theme_classic(base_size=23)+ylab('')+xlab('T-Statistics')+guides(y="none")+theme(axis.text = element_text(size=22))+ggtitle('DMN localization to Yeo7 Boundary: Right hemisphere')


# now for biol psych rois
bpalign_L=read.csv('~/Downloads/perm_vs_obs_DMN_BiolPsych_L.csv')
bpalign_R=read.csv('~/Downloads/perm_vs_obs_DMN_BiolPsych_R.csv')
# add a real vs. permuted value
bpalign_L$Observed=0
bpalign_R$Observed=0
bpalign_L$Observed[10001]=1
bpalign_R$Observed[10001]=1
# add right vs. left
bpalign_L$Side='Left'
bpalign_R$Side='Right'

# subset spun and nonspun df
spunL=bpalign_L[1:10000,]
ObsL=bpalign_L[10001,]
spunR=bpalign_R[1:10000,]
ObsR=bpalign_R[10001,]
  
# left hemi
ggplot(spunL,aes(x=Var1))+geom_density(size=1.5)+geom_vline(xintercept = ObsL$Var1,size=2,color='#BC3754')+theme_classic(base_size=23)+ylab('')+xlab('T-Statistics')+guides(y="none")+theme(axis.text = element_text(size=22))+ggtitle('DMN localization to Biol. Psych. ROIs: Left hemisphere')

# right hemi
ggplot(spunR,aes(x=Var1))+geom_density(size=1.5)+geom_vline(xintercept = ObsR$Var1,size=2,color='#BC3754')+theme_classic(base_size=23)+ylab('')+xlab('T-Statistics')+guides(y="none")+theme(axis.text = element_text(size=22))+ggtitle('DMN localization to Biol. Psych. ROIs: Right hemisphere')


```

```{r}
# calculate change in DAS to investigate inter-psychedelic-session variability
# initialize change columns
DAS_Change_Subject=c('')
DAS_Change_Dosage=c('')
DAS_Change_ChangeTA=0
DAS_Change_ChangeFC=0
DAS_Change_ChangeBUP=0
DAS_Change_ChangeMag=0

# isolate drug sessions
VASmerge_DrugSeshs=VASmerge[VASmerge$Drug==1,]
VASmerge_Plac=VASmerge[VASmerge$Drug==0,]
eachSubj=unique(VASmerge$Subjects)

# create change from placebo column
for (i in 1:length(eachSubj)){
  # extract drug sessions
  SubjDrug=VASmerge_DrugSeshs[VASmerge_DrugSeshs$Subjects==eachSubj[i],]
  Subj80=SubjDrug[SubjDrug$Dosage=='80mg',]
  Subj120=SubjDrug[SubjDrug$Dosage=='120mg',]
  # extract placebo session
  SubjPlac=VASmerge_Plac[VASmerge_Plac$Subjects==eachSubj[i],]

  # calculate mean change across scans (TA)
  TA_Plac=mean(SubjPlac$AutoCor)
  TA_80=mean(Subj80$AutoCor)
  TA_120=mean(Subj120$AutoCor)
  SubjChange_TA_80=TA_Plac-TA_80
  SubjChange_TA_120=TA_Plac-TA_120
  
  # calculate mean change across scans (DMN integration)
  FC_Plac=mean(SubjPlac$DMNFC)
  FC_80=mean(Subj80$DMNFC)
  FC_120=mean(Subj120$DMNFC)
  SubjChange_FC_80=FC_Plac-FC_80
  SubjChange_FC_120=FC_Plac-FC_120
  
  # calculate mean change across scans (BUP)
  BUP_Plac=mean(SubjPlac$TDProp1)
  BUP_80=mean(Subj80$TDProp1)
  BUP_120=mean(Subj120$TDProp1)
  SubjChange_BUP_80=BUP_Plac-BUP_80
  SubjChange_BUP_120=BUP_Plac-BUP_120
  
  # calculate mean change across scans (Magnitude)
  Mag_Plac=mean(SubjPlac$DMNMag)
  Mag_80=mean(Subj80$DMNMag)
  Mag_120=mean(Subj120$DMNMag)
  SubjChange_Mag_80=Mag_Plac-Mag_80
  SubjChange_Mag_120=Mag_Plac-Mag_120
  
  # put into VAS_change, 80mg
  DAS_Change_Subject<-c(DAS_Change_Subject,eachSubj[i])
  DAS_Change_Dosage<-c(DAS_Change_Dosage,'80mg')
  DAS_Change_ChangeFC<-c(DAS_Change_ChangeFC,SubjChange_TA_80)
  DAS_Change_ChangeTA<-c(DAS_Change_ChangeTA,SubjChange_FC_80)
  DAS_Change_ChangeBUP<-c(DAS_Change_ChangeBUP,SubjChange_BUP_80)
  DAS_Change_ChangeMag<-c(DAS_Change_ChangeMag,SubjChange_Mag_80)
  # 120
  DAS_Change_Subject<-c(DAS_Change_Subject,eachSubj[i])
  DAS_Change_Dosage<-c(DAS_Change_Dosage,'120mg')
  DAS_Change_ChangeFC<-c(DAS_Change_ChangeFC,SubjChange_TA_120)
  DAS_Change_ChangeTA<-c(DAS_Change_ChangeTA,SubjChange_FC_120)
  DAS_Change_ChangeBUP<-c(DAS_Change_ChangeBUP,SubjChange_BUP_120)
  DAS_Change_ChangeMag<-c(DAS_Change_ChangeMag,SubjChange_Mag_120)
}

DAS_changeDF=data.frame(DAS_Change_Subject,DAS_Change_Dosage,DAS_Change_ChangeFC,DAS_Change_ChangeTA,DAS_Change_ChangeBUP,DAS_Change_ChangeMag)
# drop first row (initialization row)
DAS_changeDF=DAS_changeDF[-c(1),]
colnames(DAS_changeDF)<-c('Subjects','Dosage','FC_Decrease','TA_Decrease','BUP_Decrease','Mag_Decrease')
# merge with DAS scores
DAS_changeDF=merge(DAS_changeDF,vas,by=c("Subjects","Dosage"))
# omit NA rows
DAS_changeDF=DAS_changeDF[DAS_changeDF$FC_Decrease!='NaN',]
```

```{r}
### figure 3B - coarse
# make a vector of DAS scale names \n is a newline for the ggplots
dascNames <- c(
  'Oceaninc\nBoundlessness',
  'Dread of Ego\nDissolution',
  'Visionary\nRestructuralization',
  'Auditory\nAlterations',
  'Vigilance\nReduction'
)

dascNamesAcr <- c(
  'O.B.',
  'D.E.D.',
  'V.Res.',
  'A.A.',
  'V.Red.'
)


##### Propagation directions
# initialize correlation vector for dasc
BUP_corvec=NULL
BUP_pvec=NULL
colNameVec=NULL
# initialize counter
counter=1
for (i in 44:48){
  a=cor.test(DAS_changeDF$BUP_Decrease,DAS_changeDF[,i])
  BUP_corvec[counter] <- a$estimate
  BUP_pvec[counter] <- a$p.value
  counter=counter+1
}


#########
# equivalent for AutoCor
#########

TA_corvec=NULL
TA_pvec=NULL
# initialize counter
counter=1
for (i in 44:48){
  a=cor.test(DAS_changeDF$TA_Decrease,DAS_changeDF[,i])
  TA_corvec[counter] <- a$estimate
  TA_pvec[counter] <- a$p.value
  counter=counter+1
}


#########
# equivalent for DMN seg
#########

S_corvec=NULL
S_pvec=NULL
# initialize counter
counter=1
for (i in 44:48){
  a=cor.test(DAS_changeDF$FC_Decrease,DAS_changeDF[,i])
  S_corvec[counter] <- a$estimate
  S_pvec[counter] <- a$p.value
  counter=counter+1
}

#########
# equivalent for DMN Magnitude
#########

M_corvec=NULL
M_pvec=NULL
# initialize counter
counter=1
for (i in 44:48){
  a=cor.test(DAS_changeDF$Mag_Decrease,DAS_changeDF[,i])
  M_corvec[counter] <- a$estimate
  M_pvec[counter] <- a$p.value
  counter=counter+1
}

# correct all for multiple comparisons
allPs=c(S_pvec,TA_pvec,BUP_pvec,M_pvec)
allPs_MC=p.adjust(allPs,method='fdr')

# pull out S pvecs
S_pvec_mc=allPs_MC[1:5]
TA_pvec_mc=allPs_MC[6:10]
BUP_pvec_mc=allPs_MC[11:15]
M_pvec_mc=allPs_MC[16:20]

# BAR PLOTS FOR ALL
# DMN SEGREGATION
# Create a dataframe with the values and column names
df <- data.frame(Values = S_corvec, pvals=S_pvec)

# make a color vector by significance
colorvec=rep('NS',5)
colorvec[S_pvec<.05]='Uncr'
colorvec[S_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
df$ColumnNamesAcr<-c(dascNames)
# linear version
ggplot(df, aes(x = Values, y = dascNames,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Integration")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# DMN AUTOCOTR
# Create a dataframe with the values and column names
df <- data.frame(Values = TA_corvec, pvals=TA_pvec)

# make a color vector by significance
colorvec=rep('NS',5)
colorvec[TA_pvec<.05]='Uncr'
colorvec[TA_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
df$ColumnNamesAcr<-c(dascNamesAcr)
# bar version
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Autocorrelation")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# DMN BUP
# Create a dataframe with the values and column names
df <- data.frame(Values = BUP_corvec, pvals=BUP_pvec)

# make a color vector by significance
colorvec=rep('NS',5)
colorvec[BUP_pvec<.05]='Uncr'
colorvec[BUP_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
df$ColumnNamesAcr<-c(dascNamesAcr)
# bar version
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Prop. Direction")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# DMN Mag
# Create a dataframe with the values and column names
df <- data.frame(Values = M_corvec, pvals=M_pvec)

# make a color vector by significance
colorvec=rep('NS',5)
colorvec[M_pvec<.05]='Uncr'
colorvec[M_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
df$ColumnNamesAcr<-c(dascNamesAcr)
# bar version
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Prop. Magnitudes")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# pull out BUP~DED correlation
ggplot(data=DAS_changeDF_people,aes(y=dascscore_ded,x=TDPropChange*100))+
  geom_point(size=4,aes(color = People))+
  labs(x = "Decrease in Bottom-up %", y = "Increase in Dread of Ego Dissolution", color = "People") +
  scale_color_manual(values = generated_colors) +
  theme_minimal(base_size = 16)
cor.test(DAS_changeDF_people$dascscore_ded,DAS_changeDF_people$TDPropChange)
```
```{r}
### figure 3B - granular
# make a vector of DAS scale names \n is a newline for the ggplots
dascNames=c('Experience of Unity','Spirtual Experience','Blissful State','Insightfulness','Disembodiment','Impaired Control','Anxiety','Complex Imagery','Elementary Imagery','Synsthesia','Changed meaning\n of precepts')

dascNamesAcr <- c(
  'E.U.',
  'S.E.',
  'B.S.',
  'Ins.',
  'Disemb.',
  'I.C.',
  'Anx.',
  'C.Im.',
  'E.Im.',
  'Syn.',
  'C.M.O.P.'
)
##### Propagation directions
# initialize correlation vector for dasc
BUP_corvec=NULL
BUP_pvec=NULL
colNameVec=NULL
# initialize counter
counter=1
for (i in 50:60){
  a=cor.test(DAS_changeDF$BUP_Decrease,DAS_changeDF[,i])
  BUP_corvec[counter] <- a$estimate
  BUP_pvec[counter] <- a$p.value
  counter=counter+1
}


#########
# equivalent for AutoCor
#########

TA_corvec=NULL
TA_pvec=NULL
# initialize counter
counter=1
for (i in 50:60){
  a=cor.test(DAS_changeDF$TA_Decrease,DAS_changeDF[,i])
  TA_corvec[counter] <- a$estimate
  TA_pvec[counter] <- a$p.value
  counter=counter+1
}


#########
# equivalent for DMN seg
#########

S_corvec=NULL
S_pvec=NULL
# initialize counter
counter=1
for (i in 50:60){
  a=cor.test(DAS_changeDF$FC_Decrease,DAS_changeDF[,i])
  S_corvec[counter] <- a$estimate
  S_pvec[counter] <- a$p.value
  counter=counter+1
}

#########
# equivalent for DMN Magnitude
#########

M_corvec=NULL
M_pvec=NULL
# initialize counter
counter=1
for (i in 50:60){
  a=cor.test(DAS_changeDF$Mag_Decrease,DAS_changeDF[,i])
  M_corvec[counter] <- a$estimate
  M_pvec[counter] <- a$p.value
  counter=counter+1
}

# correct all for multiple comparisons
allPs=c(S_pvec,TA_pvec,BUP_pvec,M_pvec)
allPs_MC=p.adjust(allPs,method='fdr')

# pull out S pvecs
S_pvec_mc=allPs_MC[1:11]
TA_pvec_mc=allPs_MC[12:22]
BUP_pvec_mc=allPs_MC[23:33]
M_pvec_mc=allPs_MC[34:44]

# BAR PLOTS FOR ALL
# DMN SEGREGATION
# Create a dataframe with the values and column names
df <- data.frame(Values = S_corvec, pvals=S_pvec)

# make a color vector by significance
colorvec=rep('NS',11)
colorvec[S_pvec<.05]='Uncr'
colorvec[S_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
df$ColumnNamesAcr<-c(dascNames)
# linear version
ggplot(df, aes(x = Values, y = dascNames,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Integration")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# DMN AUTOCOR
# Create a dataframe with the values and column names
df <- data.frame(Values = TA_corvec, pvals=TA_pvec)

# make a color vector by significance
colorvec=rep('NS',11)
colorvec[TA_pvec<.05]='Uncr'
colorvec[TA_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
# extra step needs to be done to maintain same row ordering as previous plot
df$ColumnNamesAcr<-c(dascNamesAcr)
df$ColumnNamesAcr<-factor(df$ColumnNamesAcr,levels=c('Anx.','B.S.','C.M.O.P.','C.Im.','Disemb.','E.Im.','E.U.','I.C.','Ins.','S.E.','Syn.'))
# bar version
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Autocorrelation")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# DMN BUP
# Create a dataframe with the values and column names
df <- data.frame(Values = BUP_corvec, pvals=BUP_pvec)

# make a color vector by significance
colorvec=rep('NS',11)
colorvec[BUP_pvec<.05]='Uncr'
colorvec[BUP_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
# extra step needs to be done to maintain same row ordering as previous plot
df$ColumnNamesAcr<-c(dascNamesAcr)
df$ColumnNamesAcr<-factor(df$ColumnNamesAcr,levels=c('Anx.','B.S.','C.M.O.P.','C.Im.','Disemb.','E.Im.','E.U.','I.C.','Ins.','S.E.','Syn.'))

# bar version
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Prop. Direction")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')
# and one just for the legend
df$Significant=df$Sig
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Significant)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Prop. Magnitudes")+theme_minimal(base_size=17)+xlim(c(-.3,.8))

# DMN Mag
# Create a dataframe with the values and column names
df <- data.frame(Values = M_corvec, pvals=M_pvec)

# make a color vector by significance
colorvec=rep('NS',11)
colorvec[M_pvec<.05]='Uncr'
colorvec[M_pvec_mc<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = '#002642', 'Uncr' = '#EF9500', 'FDR' = '#840032')
df$ColumnNamesAcr<-c(dascNamesAcr)
# bar version
ggplot(df, aes(x = Values, y = ColumnNamesAcr,fill=Sig)) +
  geom_bar(size=3,stat = "identity")+
  scale_fill_manual(values = colors) +
  labs(y = "", x = "Subscale Correlation",title="Change in Prop. Magnitudes")+theme_minimal(base_size=17)+xlim(c(-.3,.8))+
  theme(legend.position='none')

# pull out BUP~Impaired Control correlation
ggplot(data=DAS_changeDF_people,aes(y=dascscore_impair,x=TDPropChange*100))+
  geom_point(size=4,aes(color = People))+
  labs(x = "Decrease in Bottom-up %", y = "Increase in Impaired Control", color = "People") +
  scale_color_manual(values = generated_colors) +
  theme_minimal(base_size = 16)
cor.test(DAS_changeDF_people$dascscore_impair,DAS_changeDF_people$TDPropChange)

```

#### OLD BELOW

```{r}
# same, covarying for each other
# TD PROP
# initialize correlation vector for dasc
corvec=NULL
upperCIvec=NULL
lowerCIvec=NULL
pvec=NULL
colNameVec=NULL
    
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  # make a z-score das column
  VASmerge$Zed<-scale(VASmerge[,das_col])
  formula_str <- paste("Zed ~ MeanFD + RemTRs + TDProp1z+Complexityz")
  df = na.omit(VASmerge[,c("Zed",'MeanFD','RemTRs','TDProp1z','Subjects','Complexityz')])

  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1z", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1z", "p-value"]
  # get CIs
  CIs=intervals(currModel)
  upperCIvec[i-39]=CIs$fixed["TDProp1z","upper"]
  lowerCIvec[i-39]=CIs$fixed["TDProp1z","lower"]
  # edit to make corvec more interpretable
  corvec[i-39]=intervals(currModel)$fixed["TDProp1z","est."]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# 7/9/24: adding dissociation in
#model<-lme(dascscore_dissociation_SV_normed ~ TDProp1 + RemTRs + MeanFD+Task, random = ~ 1 | Subjects, data = dissoc)
#orvec[18]=summary(model)$tTable[rownames(summary(model)$tTable) == "TDProp1", "t-value"]
#pvec[18]=summary(model)$tTable[rownames(summary(model)$tTable) == "TDProp1", "p-value"]
#colNameVec[18]='Dissociation'

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec, 
                 UpperCI = upperCIvec, LowerCI = lowerCIvec)
# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = TRUE)])
#df$ColumnNamesFull<-c(dascNames,'Dissociation')
df$ColumnNamesFull<-c(dascNames)
df$ColumnNamesFull <- factor(df$ColumnNamesFull, levels = df$ColumnNamesFull[order(df$Values, decreasing = TRUE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot: note negative Values for easy interp.
ggplot(df, aes(x = -Values, y = ColumnNamesFull,color=Sig)) +
  geom_point(size=3)+
  geom_errorbarh(aes(xmin = -LowerCI, xmax = -UpperCI), height = 0.2) + # Add error bars
  scale_color_manual(values = colors) +
  labs(x = "estimate (z)", y = "DAS Questions",title="Association with Propagation Directions, Cov. for Complx.")+theme_minimal(base_size=18)




# complexity




C_corvec=NULL
C_upperCIvec=NULL
C_lowerCIvec=NULL
C_pvec=NULL
C_colNameVec=NULL

for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  # make a z-score das column
  VASmerge$Zed<-scale(VASmerge[,das_col])
  formula_str <- paste("Zed ~ MeanFD + RemTRs + Complexityz+TDProp1z")
  df = na.omit(VASmerge[,c("Zed",'MeanFD','RemTRs','Complexityz','Subjects','TDProp1z')])

  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  C_corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Complexityz", "t-value"]
  C_pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Complexityz", "p-value"]
  # get CIs
  CIs=intervals(currModel)
  C_upperCIvec[i-39]=CIs$fixed["Complexityz","upper"]
  C_lowerCIvec[i-39]=CIs$fixed["Complexityz","lower"]
  # edit to make corvec more interpretable
  C_corvec[i-39]=intervals(currModel)$fixed["Complexityz","est."]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = C_corvec, ColumnNames = colNameVec, 
                 UpperCI = C_upperCIvec, LowerCI = C_lowerCIvec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = TRUE)])
#df$ColumnNamesFull<-c(dascNames,'Dissociation')
df$ColumnNamesFull<-c(dascNames)
df$ColumnNamesFull <- factor(df$ColumnNamesFull, levels = df$ColumnNamesFull[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(C_pvec,method='fdr')
colorvec_C=rep('NS',length(fdrp))
colorvec_C[C_pvec<.05]='Uncr'
colorvec_C[C_pvec<.05]='FDR'
df$Sig_C <- factor(colorvec_C, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot: note negative Values for easy interp.
ggplot(df, aes(x = Values, y = ColumnNamesFull,color=Sig_C)) +
  geom_point(size=3)+
  geom_errorbarh(aes(xmin = LowerCI, xmax = UpperCI), height = 0.2) + # Add error bars
  scale_color_manual(values = colors) +
  labs(x = "estimate (z)", y = "DAS Questions",title="Association with Complexity, Cov. for Props.")+theme_minimal(base_size=18)
```


```{r}  
# DRUG
# initialize correlation vector for dasc
corvec=NULL
pvec=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + RemTRs + Drug")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','RemTRs','Drug','Subjects')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNames,color=Sig)) +
  geom_point(size=3) + xlim(-20,20)+
  scale_color_manual(values = colors) +
  labs(x = "Values", y = "DAS Questions",title="Association with Drug")+theme_minimal(base_size=18)



# TD, COV DRUG
# initialize correlation vector for dasc
corvec=NULL
corvecD=NULL
pvec=NULL
pvecD=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + TDProp1 + Drug + RemTRs")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','TDProp1','Subjects','Drug','RemTRs')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1", "t-value"]
  corvecD[i-39]<- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "TDProp1", "p-value"]
  pvecD[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Drug1", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNames,color=Sig)) +
  geom_point(size=3) + xlim(-20,20)+
  scale_color_manual(values = colors) +
  labs(x = "Values", y = "DAS Questions",title="TD Props, Covarying for Drug")+theme_minimal(base_size=18)

# drug covarying for td
# Create a dataframe with the values and column names
df <- data.frame(Values = corvecD, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvecD,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvecD<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNames,color=Sig)) +
  geom_point(size=3) + xlim(-20,20)+
  scale_color_manual(values = colors) +
  labs(x = "Values", y = "DAS Questions",title="Drug, Covarying for TDProps")+theme_minimal(base_size=18)


# COMPLEXITY
# initialize correlation vector for dasc
corvec=NULL
pvec=NULL
colNameVec=NULL
for (i in 40:56){
  das_col <- colnames(VASmerge)[i]
  print(das_col)
  formula_str <- paste(das_col, "~ MeanFD + Complexity + RemTRs")
  df = na.omit(VASmerge[,c(das_col,'MeanFD','Complexity','Subjects','RemTRs')])
  currModel <- lme(as.formula(formula_str), random = ~ 1 | Subjects, data = df)
  corvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Complexity", "t-value"]
  pvec[i-39] <- summary(currModel)$tTable[rownames(summary(currModel)$tTable) == "Complexity", "p-value"]
#  corvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$estimate
#  pvec[i-2]=cor.test(VASmerge$TDProp,VASmerge[,i])$p.value
  colNameVec[i-39]=colnames(VASmerge)[i]
  print(summary(currModel)$tTable)
}

# Create a dataframe with the values and column names
df <- data.frame(Values = corvec, ColumnNames = colNameVec)

# Order the ColumnNames as an ordered factor based on the Values
df$ColumnNames <- factor(df$ColumnNames, levels = df$ColumnNames[order(df$Values, decreasing = FALSE)])
df$ColumnNamesFull<-dascNames
df$ColumnNamesFull <- factor(df$ColumnNamesFull, levels = df$ColumnNamesFull[order(df$Values, decreasing = FALSE)])
# make a color vector by significance
fdrp=p.adjust(pvec,method='fdr')
colorvec=rep('NS',length(fdrp))
colorvec[pvec<.05]='Uncr'
colorvec[fdrp<.05]='FDR'
df$Sig <- factor(colorvec, levels = c('NS', 'Uncr', 'FDR'))
# Specify color scale manually
colors <- c('NS' = 'gray', 'Uncr' = 'blue', 'FDR' = 'red')
# Create the plot using ggplot
ggplot(df, aes(x = Values, y = ColumnNamesFull,color=Sig)) +
  geom_point(size=3) + xlim(-5,5)+
  scale_color_manual(values = colors) +
  labs(x = "t-Values", y = "DAS Questions",title="Association with Complexity")+theme_minimal(base_size=18)
```

```{r}
# load in angle histograms for more precise view of which direction of hierarchical propagations in changing

# placebo angles
placAngles=read.csv('~/Downloads/plac_subsAngHist.csv')

# mdma
mdmaAngles=read.csv('~/Downloads/drug_subsAngHist.csv')

# get normative sum of each column
placAnglesTot=colSums(placAngles)
# divide by total to get percentage for each
placAnglesTot=placAnglesTot/sum(placAngles)

# get normative sum of each column
mdmaAnglesTot=colSums(mdmaAngles)
# divide by total to get percentage for each
mdmaAnglesTot=mdmaAnglesTot/sum(mdmaAngles)


plotdataf<-data.frame(seq(1,18),placAnglesTot-mdmaAnglesTot)
# correct to be degrees rather than histogram bin index
plotdataf$seq.1..18.<-plotdataf$seq.1..18.*10

p<-ggplot(plotdataf,aes(x=seq.1..18.,y=placAnglesTot...mdmaAnglesTot))
p+geom_bar(stat='identity',color='black',aes(fill= ..x..),binwidth = 10)+xlab("Distance (Degrees)")+theme_classic(base_size = 23)+scale_x_continuous(limits=(c(0,190)))+scale_fill_gradientn("value",colors=c("blue","cyan","green","yellow","orange","red"))+ggtitle("Placebo - MDMA Propagation Directions")+theme(plot.title= element_text(size=30, face="bold"), axis.title = element_text(size=30, face="bold"),axis.text = element_text(face="bold",size=30),legend.title=element_blank(),legend.text=element_text(size=20),legend.position=c(1.07,.41),plot.margin=margin(b=.1,t=.1,l=.1,r=2.3, unit='cm'))+ylab('Propagation %')
```

```{r}
# simple plot of point estimates of different drugs
tvector=c(4.26465,3.63167,2.621,-0.30648,-0.27721)
drugVector=c('LSD (mice)', 'MDMA','Psilocybin','Ritalin','Ketamine')
# make dataframe
plotdf=data.frame(tvector,drugVector)
# sort order
plotdf$drugVector <- factor(plotdf$drugVector, levels = plotdf$drugVector[order(plotdf$tvector, decreasing = TRUE)])
ggplot(data=plotdf,aes(x=drugVector,y=tvector))+geom_point(size=8)+theme_minimal(base_size=30)+xlab('Drug')+ylab('t-Values')
```


```{r}
library(igraph)
# create a correlation matrix of DAS items for a spring loaded graph
Das <- vas[, 40:56]

# Calculate the correlation matrix
cor_matrix <- cor(Das, use = "complete.obs")

# Convert the correlation matrix to an adjacency matrix
# You can set a threshold to filter out weak correlations
threshold <- 0.6
adj_matrix <- cor_matrix
adj_matrix[abs(adj_matrix) < threshold] <- 0

# Create a graph object
graph <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# Set vertex labels
V(graph)$name <- dascNames

# Perform community detection using the Louvain method
communities <- cluster_louvain(graph)

# Add community membership as a vertex attribute
V(graph)$community <- communities$membership

# Set a color palette for the communities
community_colors <- rainbow(length(unique(V(graph)$community)))

layout_fr <- layout_with_fr(graph, weights = E(graph)$weight)

# Plot the graph with a spring layout and community colors
plot(graph, layout = layout_fr, vertex.label = V(graph)$name,
     vertex.size = 15, vertex.label.cex = 0.8, edge.width = E(graph)$weight * 2,
     vertex.color = community_colors[V(graph)$community], main = "Spring-loaded Graph of DAS Items with Communities")

```

```{r}
# Calculate within-module and between-module correlations for each node
within_between_ratios <- numeric(vcount(graph))

for (node in 1:vcount(graph)) {
  community <- V(graph)$community[node]
  
  # Nodes in the same community
  community_nodes <- which(V(graph)$community == community)
  
  # Nodes in different communities
  other_nodes <- which(V(graph)$community != community)
  
  # Within-module correlations
  within_correlations <- cor_matrix[node, community_nodes]
  # drop autocorrelation
  within_correlations=within_correlations[within_correlations!=1.0]
  avg_within <- mean(within_correlations[within_correlations != 0])
  
  # Between-module correlations
  between_correlations <- cor_matrix[node, other_nodes]
  avg_between <- mean(between_correlations[between_correlations != 0])
  
  if (is.na(avg_within)) avg_within <- 0
  if (is.na(avg_between)) avg_between <- 0
  
  within_between_ratios[node] <- avg_within / avg_between
}

# Normalize ratios for coloring
colors <- colorRampPalette(c("blue", "red"))(length(unique(within_between_ratios)))

# Assign colors based on normalized ratios
V(graph)$color <- colors[as.numeric(cut(within_between_ratios, breaks = length(colors)))]

# Plot the graph with a spring layout and ratio colors
plot(graph, layout = layout_fr, vertex.label = V(graph)$name,
     vertex.size = 15, vertex.label.cex = 0.8, edge.width = E(graph)$weight * 2,
     vertex.color = V(graph)$color, main = "Spring-loaded Graph of DAS Items with Within/Between Ratio")

# Additional customization (optional)
plot(graph, layout = layout_with_fr, vertex.label = V(graph)$name,
     vertex.size = 15, vertex.label.cex = 0.8, edge.width = E(graph)$weight * 2,
     vertex.color = V(graph)$color, edge.color = "gray", 
     main = "Spring-loaded Graph of DAS Items with Within/Between Ratio")
```

```{r}
# moved down 7/17/24 in favor of apriori DAS components. Below is archival code
# extract DASC
Das=vas[,40:56]
# retain parallel version with subject names and session to recover them later
Das_SubjSesh=cbind(vas$Subjects,vas$Dosage,Das)

# Remove rows with NA values
DasNoNa <- na.omit(Das)
#parallel
Das_SubjSesh=na.omit(Das_SubjSesh)

# record subjets and sessions where all = 0
ZeroIndex=rowMeans(Das_SubjSesh[,3:19])==0
zeroSubjsRemade=Das_SubjSesh[ZeroIndex,]

# Check for rows with all zeros in the cleaned data
zero_rows <- apply(DasNoNa, 1, function(x) all(x == 0))
print(any(zero_rows))  # Should print TRUE

# Remove zero rows if found
DasNoNa <- DasNoNa[!zero_rows, ]
Das_SubjSesh <-Das_SubjSesh[!zero_rows, ]

# Verify the dimensions and check for NA values
print(dim(DasNoNa))
print(any(is.na(DasNoNa)))
print(dim(Das_SubjSesh))

```
```{r}
### use the dissoc csv to get data-driven NMF components
# Load the NMF library
library(NMF)

# create DAS item-level clean data
D_IL_C=dissoc[,3:94]
# retain parallel version with subject names and session to recover them later
Das_SubjSesh=cbind(dissoc$Subjects,dissoc$Dosage,D_IL_C)
# find zero rows and columns
zero_rows <- apply(D_IL_C, 1, function(x) all(x == 0))
na_columns <- apply(D_IL_C, 2, function(x) sum(is.na(x > 0)))
# Remove zero rows if found
D_IL_C <- D_IL_C[!zero_rows, ]
# for plugging zero subjs back in later
zeroSubjsRemade=Das_SubjSesh[zero_rows,]
#zeroSubjsRemade=zeroSubjsRemade[,3:94]
# and in parallel keep subjsesh maintained
Das_SubjSesh <- Das_SubjSesh[!zero_rows, ]
# Remove zero columns if found
D_IL_C <- D_IL_C[,!na_columns]
zeroSubjsRemade=Das_SubjSesh[,!na_columns]
Das_SubjSesh <- Das_SubjSesh[,!na_columns]
# scale to max of each column
#for (c in 1:length(colnames(D_IL_C))){
#  colmax=max(D_IL_C[,c])
#  print(colmax)
#  print(c)
#  D_IL_C[,c]=D_IL_C[,c]/colmax
#}

# Function to calculate reconstruction error
reconstruction_error <- function(nmf_result, data) {
  fitted <- fitted(nmf_result)
  return(sqrt(sum((data - fitted)^2)))
}

# Range of components to test
num_components_range <- 1:20

# Store reconstruction errors
errors <- numeric(length(num_components_range))

set.seed(1)

# Calculate reconstruction errors for each number of components
#for (k in num_components_range) {
#  nmf_result <- nmf(D_IL_C, k)
#  errors[k] <- reconstruction_error(nmf_result, D_IL_C)
#}

# Plot reconstruction errors
#plot(num_components_range, errors, type = "b", pch = 19, xlab = "Number of Components", ylab = "Reconstruction Error",
#     main = "Reconstruction Error vs Number of Components")

# Set the number of components
num_components <- 15

# Run NMF
nmf_result <- nmf(D_IL_C, num_components)

# Extract the basis matrix (W) and coefficient matrix (H)
basis_matrix <- basis(nmf_result)
coef_matrix <- coef(nmf_result)

# make a vector of DAS scale names
#dascNames=c('Oceaninc Boundlessness','Dread of Ego Dissolution','Visionary Restructuralization','Auditory Alterations','Vigilance Reduction','Global Effects','Experience of Unity','Spirtual Experience','Blissful State','Insightfulness','Disembodiment','Impaired Control','Anxiety','Complex Imagery','Elementary Imagery','Synsthesia','Changed meaning of precepts')


# Function to create and print plot for a specific component
create_plot <- function(component_index){
  loadings <- coef_matrix[component_index, ]
  sorted_indices <- order(loadings, decreasing = TRUE)
  sorted_loadings <- loadings[sorted_indices]
  sorted_names <- names(na_columns[na_columns==0])[sorted_indices]
  loadings_df <- data.frame(Question = factor(sorted_names, levels = sorted_names), Loading = sorted_loadings)
  p <- ggplot(loadings_df, aes(x = Question, y = Loading)) +
    geom_bar(stat = "identity", fill = "gray") +
    ggtitle(paste("Component", component_index)) +
    theme_minimal(base_size=14) +
    theme(axis.text.x = element_text(angle = 70, hjust = 1)) +
    ylim(0, 0.35)+xlab('')
  print(p)
}
create_plot(1)
create_plot(2)
create_plot(3)
create_plot(4)
create_plot(5)
create_plot(6)
create_plot(7)
create_plot(8)
create_plot(9)
create_plot(10)
create_plot(11)
create_plot(12)
create_plot(13)
create_plot(14)
create_plot(15)

# use subj sesh to re-establish subject/session component loadings
Das_SubjSesh$Comp1<-basis_matrix[,1]
Das_SubjSesh$Comp2<-basis_matrix[,2]
Das_SubjSesh$Comp3<-basis_matrix[,3]
Das_SubjSesh$Comp4<-basis_matrix[,4]
Das_SubjSesh$Comp5<-basis_matrix[,5]
Das_SubjSesh$Comp6<-basis_matrix[,6]
Das_SubjSesh$Comp7<-basis_matrix[,7]
Das_SubjSesh$Comp8<-basis_matrix[,8]
Das_SubjSesh$Comp9<-basis_matrix[,9]
Das_SubjSesh$Comp10<-basis_matrix[,10]
Das_SubjSesh$Comp11<-basis_matrix[,11]
Das_SubjSesh$Comp12<-basis_matrix[,12]
Das_SubjSesh$Comp13<-basis_matrix[,13]
Das_SubjSesh$Comp14<-basis_matrix[,14]
Das_SubjSesh$Comp15<-basis_matrix[,15]
```

```{r}
# set column names to equivalent
colnames(Das_SubjSesh)[1:2]<-c('Subjects','Dosage')
colnames(zeroSubjsRemade)[1:2]<-c('Subjects','Dosage')
#### you CAN re-insert the 0-DAS items row for an extra piece of brain data... safe to assume they #would load as 0 onto all components
zeroSubjsRemade$Comp1<-0
zeroSubjsRemade$Comp2<-0
zeroSubjsRemade$Comp3<-0
zeroSubjsRemade$Comp4<-0
zeroSubjsRemade$Comp5<-0
zeroSubjsRemade$Comp6<-0
zeroSubjsRemade$Comp7<-0
zeroSubjsRemade$Comp8<-0
zeroSubjsRemade$Comp9<-0
zeroSubjsRemade$Comp10<-0
zeroSubjsRemade$Comp11<-0
zeroSubjsRemade$Comp12<-0
zeroSubjsRemade$Comp13<-0
zeroSubjsRemade$Comp14<-0
zeroSubjsRemade$Comp15<-0
#
## add back in
Das_SubjSesh=rbind(Das_SubjSesh,zeroSubjsRemade)
#
## regenerate 
mergedDf=merge(Das_SubjSesh,mergedDfPropsComplAutoC,by=c("Subjects","Dosage"))
#
## loop over each component (1-15), return coefficient and p-value of association with both #complexity and tdprop1, populate 4 resultant vectors with these values for subsequent plotting
#
## Initialize vectors to store coefficients and p-values for subsequent plotting
coef_complexity <- numeric(15)
pval_complexity <- numeric(15)
coef_tdprop1 <- numeric(15)
pval_tdprop1 <- numeric(15)
#
## Loop over each component (1-15)
library(nlme)
for (i in 1:15) {
  # Construct the formula dynamically for the current component
  formulaTD <- as.formula(paste("Comp", i, " ~ MeanFD + RemTRs + TDProp1+ Complexity", sep = ""))
  formulaCompl <- as.formula(paste("Comp", i, " ~ MeanFD + RemTRs + Complexity", sep = ""))
  # Fit the linear mixed-effects model
  modelT <- lme(formulaTD, random = ~ 1 | Subjects, data = mergedDf)
  modelC <- lme(formulaCompl, random = ~ 1 | Subjects, data = mergedDf)
  # Extract coefficients and p-values for both Complexity (Intercept) and TDProp1
  coef_complexity[i] <- summary(modelC)$tTable["Complexity", "t-value"]
  pval_complexity[i] <- summary(modelC)$tTable["Complexity", "p-value"]
  coef_tdprop1[i] <- summary(modelT)$tTable["TDProp1", "t-value"]
  pval_tdprop1[i] <- summary(modelT)$tTable["TDProp1", "p-value"]
}

```


```{r}
# recreate with 5 components, more succinct
# LOW DIMENSIONAL SOLUTION
# create DAS item-level clean data
D_IL_C=dissoc[,3:94]
# retain parallel version with subject names and session to recover them later
Das_SubjSesh=cbind(dissoc$Subjects,dissoc$Dosage,D_IL_C)
# find zero rows and columns
zero_rows <- apply(D_IL_C, 1, function(x) all(x == 0))
na_columns <- apply(D_IL_C, 2, function(x) sum(is.na(x > 0)))
# Remove zero rows if found
D_IL_C <- D_IL_C[!zero_rows, ]
# for plugging zero subjs back in later
zeroSubjsRemade=Das_SubjSesh[zero_rows,]
#zeroSubjsRemade=zeroSubjsRemade[,3:94]
# and in parallel keep subjsesh maintained
Das_SubjSesh <- Das_SubjSesh[!zero_rows, ]
# Remove zero columns if found
D_IL_C <- D_IL_C[,!na_columns]
zeroSubjsRemade=Das_SubjSesh[,!na_columns]
Das_SubjSesh <- Das_SubjSesh[,!na_columns]
# Set the number of components
num_components <- 5

# Run NMF
nmf_result <- nmf(D_IL_C, num_components)

# Extract the basis matrix (W) and coefficient matrix (H)
basis_matrix <- basis(nmf_result)
coef_matrix <- coef(nmf_result)

# make a vector of DAS scale names
#dascNames=c('Oceaninc Boundlessness','Dread of Ego Dissolution','Visionary Restructuralization','Auditory Alterations','Vigilance Reduction','Global Effects','Experience of Unity','Spirtual Experience','Blissful State','Insightfulness','Disembodiment','Impaired Control','Anxiety','Complex Imagery','Elementary Imagery','Synsthesia','Changed meaning of precepts')


# Function to create and print plot for a specific component
create_plot <- function(component_index){
  loadings <- coef_matrix[component_index, ]
  sorted_indices <- order(loadings, decreasing = TRUE)
  sorted_loadings <- loadings[sorted_indices]
  sorted_names <- names(na_columns[na_columns==0])[sorted_indices]
  loadings_df <- data.frame(Question = factor(sorted_names, levels = sorted_names), Loading = sorted_loadings)
  p <- ggplot(loadings_df, aes(x = Question, y = Loading)) +
    geom_bar(stat = "identity", fill = "gray") +
    ggtitle(paste("Component", component_index)) +
    theme_minimal(base_size=14) +
    theme(axis.text.x = element_text(angle = 70, hjust = 1)) +
    ylim(0, 0.55)+xlab('')
  print(p)
}
create_plot(1)
create_plot(2)
create_plot(3)
create_plot(4)
create_plot(5)

# use subj sesh to re-establish subject/session component loadings
Das_SubjSesh$Comp1<-basis_matrix[,1]
Das_SubjSesh$Comp2<-basis_matrix[,2]
Das_SubjSesh$Comp3<-basis_matrix[,3]
Das_SubjSesh$Comp4<-basis_matrix[,4]
Das_SubjSesh$Comp5<-basis_matrix[,5]

# set column names to equivalent
colnames(Das_SubjSesh)[1:2]<-c('Subjects','Dosage')
colnames(zeroSubjsRemade)[1:2]<-c('Subjects','Dosage')
#### you CAN re-insert the 0-DAS items row for an extra piece of brain data... safe to assume they #would load as 0 onto all components
zeroSubjsRemade$Comp1<-0
zeroSubjsRemade$Comp2<-0
zeroSubjsRemade$Comp3<-0
zeroSubjsRemade$Comp4<-0
zeroSubjsRemade$Comp5<-0

#
## add back in
Das_SubjSesh=rbind(Das_SubjSesh,zeroSubjsRemade)
#
## regenerate 
mergedDf=merge(Das_SubjSesh,mergedDfPropsComplAutoC,by=c("Subjects","Dosage"))
#
## loop over each component (1-5), return coefficient and p-value of association with both #complexity and tdprop1, populate 4 resultant vectors with these values for subsequent plotting
#
## Initialize vectors to store coefficients and p-values for subsequent plotting
coef_complexity <- numeric(5)
pval_complexity <- numeric(5)
coef_tdprop1 <- numeric(5)
pval_tdprop1 <- numeric(5)
#
## Loop over each component (1-5)
library(nlme)
for (i in 1:5) {
  # Construct the formula dynamically for the current component
  formulaTD <- as.formula(paste("Comp", i, " ~ MeanFD + RemTRs + TDProp1+ Complexity", sep = ""))
  formulaCompl <- as.formula(paste("Comp", i, " ~ MeanFD + RemTRs + Complexity", sep = ""))
  # Fit the linear mixed-effects model
  modelT <- lme(formulaTD, random = ~ 1 | Subjects, data = mergedDf)
  modelC <- lme(formulaCompl, random = ~ 1 | Subjects, data = mergedDf)
  # Extract coefficients and p-values for both Complexity (Intercept) and TDProp1
  coef_complexity[i] <- summary(modelC)$tTable["Complexity", "t-value"]
  pval_complexity[i] <- summary(modelC)$tTable["Complexity", "p-value"]
  coef_tdprop1[i] <- summary(modelT)$tTable["TDProp1", "t-value"]
  pval_tdprop1[i] <- summary(modelT)$tTable["TDProp1", "p-value"]
}

```
```{r}
# plot it
library(circular)
library(plotrix)

## Adjust p-values for multiple comparisons using FDR method
pval_complexity_mc <- p.adjust(pval_complexity, method = 'fdr')
pval_tdprop1_mc <- p.adjust(pval_tdprop1, method = 'fdr')

## Create a data frame with the coefficients and p-values
plot_df <- data.frame(
  Component = factor(1:5),
  Coef_Complexity = coef_complexity,
  Pval_Complexity = pval_complexity,
  # - for interpretative simplicity: converts % bottom-up to % Top-down
  Coef_TDProp1 = -coef_tdprop1,
  Pval_TDProp1 = pval_tdprop1,
  Pval_Complexity_MC = pval_complexity_mc,
  Pval_TDProp1_MC = pval_tdprop1_mc
)

## Function to generate circular barplot with three colors
circular_barplot <- function(df, coef_column, pval_column, pval_mc_column, title) {
  ggplot(df, aes(x = Component, y = !!sym(coef_column))) +
    geom_bar(aes(fill = factor(ifelse(!!sym(pval_mc_column) < 0.05, "FDR", 
                                      ifelse(!!sym(pval_column) < 0.05, "Uncr", "NS")))), 
             stat = "identity", width = 0.8) +
    scale_fill_manual(values = c("FDR" = "red", "Uncr" = "blue", "NS" = "grey")) +
    coord_polar(theta = "x", start = 0) +
    labs(title = title, fill = "P-value") +
    theme_minimal(base_size=28) +
    theme(
      #axis.text.x = element_text(size = 28),
      axis.title = element_blank()
    )
}
#
circular_barplot(plot_df, "Coef_Complexity", "Pval_Complexity", "Pval_Complexity_MC", "Coefficients of Complexity")
#
circular_barplot(plot_df, "Coef_TDProp1", "Pval_TDProp1", "Pval_TDProp1_MC", "Coefficients of DMN Prop. Directions")

```

```{r}
# and an all-questions version
coef_complexity <- NULL
pval_complexity <- NULL
coef_tdprop1 <- NULL
pval_tdprop1 <- NULL
question_name <- NULL

zero_rows <- apply(mergedDf, 1, function(x) all(x == 0))
na_columns <- apply(mergedDf, 2, function(x) sum(is.na(x > 0)))

mergedDf_noMissing=mergedDf[!zero_rows,]
mergedDf_noMissing=mergedDf_noMissing[,!na_columns]

for (i in 3:91) {
  # Construct the formula dynamically for the current component
  formulaTD <- as.formula(paste(colnames(mergedDf_noMissing)[i], " ~ MeanFD + RemTRs + TDProp1", sep = ""))
  formulaCompl <- as.formula(paste(colnames(mergedDf_noMissing)[i], " ~ MeanFD + RemTRs + Complexity", sep = ""))
  # Fit the linear mixed-effects model
  modelT <- lme(formulaTD, random = ~ 1 | Subjects, data = mergedDf)
  modelC <- lme(formulaCompl, random = ~ 1 | Subjects, data = mergedDf)
  # Extract coefficients and p-values for both Complexity (Intercept) and TDProp1
  coef_complexity[i-2] <- summary(modelC)$tTable["Complexity", "t-value"]
  pval_complexity[i-2] <- summary(modelC)$tTable["Complexity", "p-value"]
  coef_tdprop1[i-2] <- summary(modelT)$tTable["TDProp1", "t-value"]
  pval_tdprop1[i-2] <- summary(modelT)$tTable["TDProp1", "p-value"]
  question_name[i-2] <- colnames(mergedDf_noMissing)[i]
}

## Adjust p-values for multiple comparisons using FDR method
pval_complexity_mc <- p.adjust(pval_complexity, method = 'fdr')
pval_tdprop1_mc <- p.adjust(pval_tdprop1, method = 'fdr')

## Create a data frame with the coefficients and p-values
plot_df <- data.frame(
  Component = factor(question_name),
  Coef_Complexity = coef_complexity,
  Pval_Complexity = pval_complexity,
  # - for interpretative simplicity: converts % bottom-up to % Top-down
  Coef_TDProp1 = -coef_tdprop1,
  Pval_TDProp1 = pval_tdprop1,
  Pval_Complexity_MC = pval_complexity_mc,
  Pval_TDProp1_MC = pval_tdprop1_mc
)


circular_barplot(plot_df, "Coef_Complexity", "Pval_Complexity", "Pval_Complexity_MC", "Coefficients of Complexity")

circular_barplot(plot_df, "Coef_TDProp1", "Pval_TDProp1", "Pval_TDProp1_MC", "Coefficients of DMN Prop. Directions")

```

```{r}
# bootstrap approach to determine if two t-stats are different
boot_df_coefsTD=array(0,dim=c(100,89))
boot_df_coefsComplex=array(0,dim=c(100,89))
question_name=NULL
# glean number of subjects
numSubjs=length(unique(mergedDf_noMissing$Subjects))
# get those subjs
subjs=unique(mergedDf_noMissing$Subjects)

# b = 1 as tmp for speedy re-running
for (b in 1){
  print(b)
  BootSubjs=sample(subjs,numSubjs,replace=T)
  bootSamp <- data.frame()
  for (j in 1:length(BootSubjs)){
    subject_obs <- mergedDf_noMissing[mergedDf_noMissing$Subjects == BootSubjs[j], ]
    bootSamp <- rbind(bootSamp, subject_obs)
  }
  # run tests
  for (i in 3:91) {
    # calculate range in question answers in this bootstrap
    dasItemRange=range(bootSamp[,colnames(mergedDf_noMissing)[i]])[2]-range(bootSamp[,colnames(mergedDf_noMissing)[i]])[1]
    # if there is enoughdata in the bootstrapped dasc item
    if (dasItemRange>30){
    # Construct the formula dynamically for the current component
    formulaTD <- as.formula(paste(colnames(mergedDf_noMissing)[i], " ~ MeanFD + RemTRs + TDProp1", sep = ""))
    formulaCompl <- as.formula(paste(colnames(mergedDf_noMissing)[i], " ~ MeanFD + RemTRs + Complexity", sep = ""))
    # Fit the linear mixed-effects model
    modelT <- lme(formulaTD, random = ~ 1 | Subjects, data = bootSamp)
    modelC <- lme(formulaCompl, random = ~ 1 | Subjects, data = bootSamp)
    # Extract coefficients and p-values for both Complexity (Intercept) and TDProp1
    boot_df_coefsComplex[b,i-2] <- summary(modelC)$tTable["Complexity", "t-value"]
    boot_df_coefsTD[b,i-2] <- summary(modelT)$tTable["TDProp1", "t-value"]
    question_name[i-2] <- colnames(mergedDf_noMissing)[i]
    } 
  }
}

# initialize t-diff
tdiff=array(0,dim=c(100,89))

# plot distributions of t-diff (omit instances where t=0, not populated due to enough data constraint)
for (i in 1:ncol(tdiff)){
  for (b in 1:100){
    if (boot_df_coefsComplex[b,i]!=0 && boot_df_coefsTD[b,i]!=0){
    tdiff[b,i]=boot_df_coefsComplex[b,i]-(-boot_df_coefsTD[b,i])
    }
  }
}
tdiffPropNeg=rep(0,89)
tdiffPropPos=rep(0,89)
# get manual p-values, described as proportion of non-zero entries where tdiff is consistently positive or negative
for (i in 1:ncol(tdiff)){
  # nonzero rows
  nonzeroRows=tdiff[,i]!=0
  tdiffPropNeg[i]=sum(tdiff[nonzeroRows,i]<0)/sum(nonzeroRows)
  tdiffPropPos[i]=sum(tdiff[nonzeroRows,i]>0)/sum(nonzeroRows)
}
# get na indices
NA_indicesNeg=is.na(tdiffPropNeg)
NA_indicesPos=is.na(tdiffPropPos)
# convert to p-values
tdiffProp_neg_ps=tdiffPropNeg[!NA_indicesNeg]
tdiffProp_pos_ps=tdiffPropPos[!NA_indicesPos]

tdiffProp_neg_ps_mc=p.adjust(tdiffProp_neg_ps,method='fdr')
tdiffProp_pos_ps_mc=p.adjust(tdiffProp_pos_ps,method='fdr')


# use NA indices to get question names out
question_nameIndexedNeg=question_name[!NA_indicesNeg]
question_nameIndexedPos=question_name[!NA_indicesPos]
ComplexityGreater=question_nameIndexedPos[tdiffProp_pos_ps_mc<0.05]
TDPropGreater=question_nameIndexedNeg[tdiffProp_neg_ps_mc<0.05]
# doesn't match, need to check indexing
```
